# HG changeset patch
# Parent 845b7ac1267167484ede295b881c4bdc420fdc79
Add Danube Board

--- /dev/null
+++ b/board/danube/Kconfig
@@ -0,0 +1,64 @@
+#
+# For a description of the syntax of this configuration file,
+# see Linux Documentation
+#
+#
+
+config DRIVER_DANUBE
+      bool
+      default y
+
+config BOARD_NAME
+    string
+	default "EASY50712"
+	depends on IFX_IMAGE_EXTRA_CHECKS
+
+config BOARD_VERSION
+    string
+    default "1.26"
+    depends on IFX_IMAGE_EXTRA_CHECKS
+
+config CHIP_NAME
+    string
+    default "DANUBE"
+    depends on IFX_IMAGE_EXTRA_CHECKS
+
+config CHIP_VERSION
+    string
+    default "1.2"
+    depends on IFX_IMAGE_EXTRA_CHECKS
+
+choice
+    prompt 'RAM BRAND'
+	    default DANUBE_ETRON_RAM
+
+    config DANUBE_QIMONDA_RAM
+	    bool "QIMONDA"
+
+	config DANUBE_ETRON_RAM
+	    bool "ETRON"
+
+	config DANUBE_PROMOS_RAM
+	    bool "PROMOS"
+
+	config DANUBE_PSC_RAM	
+	    bool "PSC"
+
+    config DANUBE_SAMSUNG_RAM
+	    bool "SAMSUNG"
+
+endchoice
+					
+
+
+config TUNE_DDR
+    bool "DDR tuning support"
+	default y
+
+config DDR_TUNING_TEXT_BASE
+    hex 
+        default "0x9e1a0000"
+    depends on TUNE_DDR
+
+
+
--- /dev/null
+++ b/board/danube/Makefile
@@ -0,0 +1,63 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+OBJS_SFDDR = start_sf.o sf_board.o tune_ddr.o lowlevel_init.o
+LIBS_SFDDR = $(TOPDIR)/lib/string.o
+LIBS_SFDDR += $(TOPDIR)/lib/crc32.o
+LIBS_SFDDR += $(TOPDIR)/$(CPUDIR)/$(BOARD)/clock.o
+LIBS_SFDDR += $(TOPDIR)/drivers/serial/lq_asc.o
+LIBS_SFDDR += $(TOPDIR)/arch/mips/lib/time.o
+
+
+COBJS	= $(BOARD).o 
+SOBJS	= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+
+sfddr: .depend $(OBJS_SFDDR)
+	$(LD)  -Bstatic -T bootstrap.lds -Ttext 0xbe1a0000 $(OBJS_SFDDR) $(LIBS_SFDDR) -o sfddr
+
+
+tune_ddr.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/lib_bootstrap/tune_ddr.c $@ 
+
+	
+	
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- /dev/null
+++ b/board/danube/Makefile.lq
@@ -0,0 +1,77 @@
+
+
+ALL +=bootstrap.bin u-boot.lzimg u-boot.lq
+
+
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARD)/bootstrap.lds
+ifdef CONFIG_BOOT_FROM_NOR
+OBJS_BOOTSTRAP  = $(TOPDIR)/$(CPUDIR)/$(BOARD)/start_bootstrap.o
+OBJS_BOOTSTRAP  += $(TOPDIR)/board/$(BOARD)/lowlevel_init.o
+else 
+OBJS_BOOTSTRAP  = $(TOPDIR)/$(CPUDIR)/$(BOARD)/start_uncomp.o
+endif
+
+
+
+OBJS_BOOTSTRAP  += $(TOPDIR)/lib/string.o
+OBJS_BOOTSTRAP  += $(CPUDIR)/$(BOARD)/lib$(CPU).a
+LIBS_BOOTSTRAP  = $(TOPDIR)/lib_bootstrap/libbootstrap.a
+LIBS_BOOTSTRAP += $(TOPDIR)/lib/crc32.o
+LIBS_BOOTSTRAP += $(TOPDIR)/drivers/serial/lq_asc.o
+LIBS_BOOTSTRAP += $(TOPDIR)/$(CPUDIR)/$(BOARD)/clock.o
+#LIBS_BOOTSTRAP += $(TOPDIR)/$(CPUDIR)/$(BOARD)/asc.o
+LIBS_BOOTSTRAP += $(TOPDIR)/arch/mips/lib/time.o
+
+
+BOOTSTRAP_LDFLAGS = -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(CONFIG_BOOTSTRAP_TEXT_BASE) 
+
+ifdef CONFIG_BOOT_FROM_NOR
+$(obj)u-boot.lq: $(obj)System.map $(obj)bootstrap.bin $(obj)u-boot.lzimg
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.lq
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.lq
+endif
+
+ifdef CONFIG_BOOT_FROM_NAND
+$(obj)u-boot.lq: $(obj)System.map $(obj)bootstrap.bin $(obj)u-boot.lzimg
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 10240 bootstrap.bin
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.lq
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.lq
+endif
+
+ifdef CONFIG_BOOT_FROM_SPI
+$(obj)u-boot.lq: $(obj)System.map $(obj)bootstrap.bin $(obj)u-boot.lzimg sfddr.bin
+		@touch dummy
+		@$(TOPDIR)/scripts_platform/mk_sf.pl dummy sfddr.bin $(CONFIG_SFDDR_TEXT_BASE) u-boot.lq
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 16384 u-boot.lq
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 10240 bootstrap.bin
+		@cat $(obj)bootstrap.bin >> $(obj)u-boot.lq
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.lq
+endif
+						
+
+sfddr.bin:
+		@rm -f $@
+		@make -C $(TOPDIR)/board/$(BOARD) sfddr
+		@ln -s $(TOPDIR)/board/$(BOARD)/sfddr sfddr
+		@$(OBJCOPY) ${OBJCFLAGS} -O binary sfddr $@
+
+u-boot.lzimg: $(obj)u-boot.bin System.map
+		lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		scripts_platform/pad2align.sh -n 16 u-boot.lzma
+		$(TOPDIR)/tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.lzma $@
+															
+
+
+bootstrap.bin:    $(obj)bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+		
+bootstrap: $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP)  $(LDSCRIPT_BOOTSTRAP)
+		$(LD) $(BOOTSTRAP_LDFLAGS) $$UNDEF_SYM $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) \
+		-Map bootstrap.map -o bootstrap
+		
+$(LIBS_BOOTSTRAP):
+		$(MAKE) -C `dirname $@` all
+		
--- /dev/null
+++ b/board/danube/bootstrap.lds
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	. = ALIGN(16);
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+
+    . = ALIGN(4);
+	uboot_end_data = .;
+	got_size = (__got_end - __got_start);
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+  . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
--- /dev/null
+++ b/board/danube/config.mk
@@ -0,0 +1,27 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+-include $(TOPDIR)/.config
+
+TEXT_BASE = $(CONFIG_RAM_TEXT_BASE)
+
--- /dev/null
+++ b/board/danube/danube.c
@@ -0,0 +1,307 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+//#include <asm/danube.h>
+#include <environment.h>
+#include <spi_flash.h>
+
+#ifndef CONFIG_ENV_SPI_BUS
+# define CONFIG_ENV_SPI_BUS 0
+#endif
+#ifndef CONFIG_ENV_SPI_CS
+# define CONFIG_ENV_SPI_CS      0
+#endif
+#ifndef CONFIG_ENV_SPI_MAX_HZ
+# define CONFIG_ENV_SPI_MAX_HZ  1000000
+#endif
+#ifndef CONFIG_ENV_SPI_MODE
+# define CONFIG_ENV_SPI_MODE    SPI_MODE_3
+#endif
+
+#ifdef CONFIG_NOR_FLASH_AUTO
+void save_extra_env()
+{
+   extern flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+   extern xway_flash_partition_map_info flash_map[];
+   int i,j,total_db,total_part;
+   int mtd_part;
+   u32  tmp;
+   char strTemp[32], strCommand[128];
+   char strimg_addr[32],strimg_size[32],strimg_end[32];
+   i=0;
+   while(flash_map[i].size !=0){
+    	 if(flash_map[i].size == flash_info[0].size>>20) break;
+    	 i++;
+    }
+   total_db = 0;
+   mtd_part = -1; 
+   total_part = 0;
+   for(j=0;j<XWAY_MAX_BLOCK_NUM;j++){
+   	     if(strcmp(flash_map[i].block[j].blockName,"")!=0){
+   	     	 total_db++;
+   	     	 
+   	     	 sprintf(strTemp,"data_block%d",j);
+   	     	 if(!getenv(strTemp)) setenv(strTemp, flash_map[i].block[j].blockName);
+           sprintf(strTemp,"f_%s_addr",flash_map[i].block[j].blockName);
+           sprintf(strimg_addr,"0x%08x",flash_map[i].block[j].startAddr);
+           if(!getenv(strTemp)) setenv(strTemp,strimg_addr);
+           if(flash_map[i].block[j].mtdNum!=mtd_part){
+   	     	    mtd_part = flash_map[i].block[j].mtdNum;
+   	     	    total_part ++;
+   	     	    sprintf(strTemp, "part%d_begin", j);
+   	     	    if(!getenv(strTemp)) setenv(strTemp,strimg_addr);	
+   	     	 }
+           
+           	sprintf(strTemp,"f_%s_size",flash_map[i].block[j].blockName);
+            sprintf(strimg_size,"0x%08x",flash_map[i].block[j].sizeBytes);
+            if(!getenv(strTemp)) setenv(strTemp,strimg_size);
+            sprintf(strTemp,"f_%s_end",flash_map[i].block[j].blockName);
+            sprintf(strimg_end,"0x%08x", flash_map[i].block[j].startAddr + flash_map[i].block[j].sizeBytes - 1);
+            if(!getenv(strTemp)) setenv(strTemp,strimg_end);
+             	
+            if(strcmp(flash_map[i].block[j].blockName,"ubootconfig")==0) {
+           	   sprintf(strCommand,"prot off 0x%08x %s;erase 0x%08x %s 1",\
+           	           flash_map[i].block[j].startAddr,strimg_end,\
+           	           flash_map[i].block[j].startAddr,strimg_end);
+           	   sprintf(strTemp,"reset_uboot_config");
+           	   if(!getenv(strTemp)) setenv(strTemp,strCommand);        
+           	
+            }
+            
+                       
+        }
+    } 
+    sprintf(strTemp, "%d", total_db);
+    if(!getenv(strTemp)) setenv("total_db", strTemp);
+    sprintf(strTemp, "%d", total_part);
+    if(!getenv(strTemp)) setenv("total_part", strTemp);
+    sprintf(strTemp, "0x%08x", 0xb0000000 + flash_info[0].size);
+    if(!getenv(strTemp)) setenv("flash_end", strTemp);
+    sprintf(strTemp, "mtdparts");
+    if(!getenv(strTemp)) setenv(strTemp,flash_map[i].mtdparts);	
+    	
+   return;
+}
+
+#endif
+
+#ifdef CONFIG_NAND_FLASH
+void nand_gpio_init(void)
+{
+    //Set GPIO23 to be Flash CS1;
+	*DANUBE_GPIO_P1_ALTSEL0 = *DANUBE_GPIO_P1_ALTSEL0 | (1<<7) | (1<<8);
+	*DANUBE_GPIO_P1_ALTSEL1 = *DANUBE_GPIO_P1_ALTSEL1 & ~(1<<7) & ~ (1<<8);
+	*DANUBE_GPIO_P1_DIR = *DANUBE_GPIO_P1_DIR | (1<<7) | (1<<8);
+	*DANUBE_GPIO_P1_OD = *DANUBE_GPIO_P1_OD | (1<<7) | (1<<8) ;
+	(*DANUBE_GPIO_P0_ALTSEL0) = (*DANUBE_GPIO_P0_ALTSEL0) | (1<<13);
+	//Set GPIO 13 to ND_ALE
+	(*DANUBE_GPIO_P0_ALTSEL1) = (*DANUBE_GPIO_P0_ALTSEL1) &  ~(1<<13);
+	(*DANUBE_GPIO_P0_OD) = (*DANUBE_GPIO_P0_OD) | (1<<13) ;
+	(*DANUBE_GPIO_P0_DIR) =	(*DANUBE_GPIO_P0_DIR) | (1<<13) ; // set GPIO 13 to output
+																			
+    return;
+}
+
+#endif
+
+#ifdef CONFIG_LANTIQ_SPI
+#define BIT(X)       (1 << (X))
+#define SPI_MODULO   16
+#define SPI_CS4     (10 & 0xF)  /* P0.10 */
+#define SPI_DIN     (16 & 0xF)  /* P1.0 */
+#define SPI_DOUT    (17 & 0xF)  /* P1.1 */
+#define SPI_CLK     (18 & 0xF)  /* P1.2 */
+
+typedef struct spi_cs_gpio{
+   u8 port;
+   u8 pin;
+   u8 dir;
+   u8 alt0;
+   u8 alt1;
+};
+
+int spi_gpio_init(unsigned int cs)
+{
+	   struct spi_cs_gpio cs_gpio[5]={
+                {0, 15, 1, 0, 1},
+				{1, 6,  1, 0, 1},
+				{0, 13, 1, 1, 0},
+				{0, 10, 1, 1, 0},
+				{0, 9,  1, 1, 0}
+				};
+	  if(cs<0 || cs>5) return 0; /*cs pin out of range*/          
+	
+      if(cs_gpio[cs].port == 0)
+	  {
+        *(DANUBE_GPIO_P0_DIR)     |= BIT(cs_gpio[cs].pin);
+		*(DANUBE_GPIO_P0_ALTSEL0) = (*(DANUBE_GPIO_P0_ALTSEL0) & ~BIT(cs_gpio[cs].alt0))|BIT(cs_gpio[cs].alt0);
+		*(DANUBE_GPIO_P0_ALTSEL1) = (*(DANUBE_GPIO_P0_ALTSEL1) & ~BIT(cs_gpio[cs].alt1))|BIT(cs_gpio[cs].alt1);
+		*(DANUBE_GPIO_P0_OD)      |= BIT(cs_gpio[cs].pin);
+	  }
+	  else
+	  {
+	    *(DANUBE_GPIO_P1_DIR)     |= BIT(cs_gpio[cs].pin);
+	    *(DANUBE_GPIO_P1_ALTSEL0) = (*(DANUBE_GPIO_P1_ALTSEL0) & ~BIT(cs_gpio[cs].alt0))|BIT(cs_gpio[cs].alt0);
+		*(DANUBE_GPIO_P1_ALTSEL1) = (*(DANUBE_GPIO_P1_ALTSEL1) & ~BIT(cs_gpio[cs].alt1))|BIT(cs_gpio[cs].alt1);
+		*(DANUBE_GPIO_P1_OD)      |= BIT(cs_gpio[cs].pin);
+										
+	  }
+	  /* p1.0 SPI_DIN, p1.1 SPI_DOUT, p1.2 SPI_CLK */
+	  *(DANUBE_GPIO_P1_DIR)      = ((*DANUBE_GPIO_P1_DIR)| BIT(SPI_DOUT) | BIT(SPI_CLK))&(~BIT(SPI_DIN));
+	  *(DANUBE_GPIO_P1_ALTSEL0) |= (BIT(SPI_DOUT) | BIT(SPI_CLK) | BIT(SPI_DIN));
+	  *(DANUBE_GPIO_P1_ALTSEL1) &= ~(BIT(SPI_DOUT) | BIT(SPI_CLK) | BIT(SPI_DIN));
+	  *(DANUBE_GPIO_P1_OD)      |= (BIT(SPI_DOUT) | BIT(SPI_CLK));
+#if 0
+         *(DANUBE_GPIO_P0_DIR) = (*DANUBE_GPIO_P0_DIR)|(0xAE00);
+		 *(DANUBE_GPIO_P0_ALTSEL0) = (((*DANUBE_GPIO_P0_ALTSEL0)|(0x8000)) & (~(0x2E00)));
+		 *(DANUBE_GPIO_P0_ALTSEL1) = (((*DANUBE_GPIO_P0_ALTSEL1)&(~0x8000)) & (~(0x2E00)) );
+		 *(DANUBE_GPIO_P0_OD) = (*DANUBE_GPIO_P0_OD)|0xAE00;
+
+		  /* p1.6 SPI_CS2(SFLASH), p1.0 SPI_DIN, p1.1
+		 * SPI_DOUT, p1.2 SPI_CLK */
+		 *(DANUBE_GPIO_P1_DIR) =  ((*DANUBE_GPIO_P1_DIR)|(0x46))&(~1);
+		 *(DANUBE_GPIO_P1_ALTSEL0) = ((*DANUBE_GPIO_P1_ALTSEL0)|(0x47));
+		 *(DANUBE_GPIO_P1_ALTSEL1) = (*DANUBE_GPIO_P1_ALTSEL1)&(~0x47);
+		 *(DANUBE_GPIO_P1_OD) = (*DANUBE_GPIO_P1_OD)|0x0046;
+#endif     
+     return 1;
+}
+#endif
+
+#ifdef CONFIG_TUNE_DDR
+#ifdef CONFIG_BOOT_FROM_NOR
+void save_ddr_param(void)
+{
+     int rcode;
+	 ulong   ddr_magic=0x88888888;
+	 ulong erase_addr1=0, erase_addr2=0;
+	 volatile ulong* ptr=IFX_CFG_FLASH_DDR_CFG_START_ADDR;
+	 ulong  ecc;
+	 ulong  buffer[6];
+	 erase_addr1 = IFX_CFG_FLASH_DDR_CFG_START_ADDR; 
+	 erase_addr2 = IFX_CFG_FLASH_DDR_CFG_START_ADDR + IFX_CFG_FLASH_DDR_CFG_SIZE;
+	 if(*(u32*)0xbe1a5f20!=0x2)  /*0xBE1A5F20 contains the tuning status*/
+	    {
+		    /*no new parameter, return immediately*/
+		    return;
+	    }
+#if 0	 
+	 if(*ptr==ddr_magic)
+	     {
+		     ecc=(*(ptr+1))^(*(ptr+2))^(*(ptr+3))^(*(ptr+4));
+			 if(ecc==*(ptr+5)) return; /*already tuned, return then*/
+		 }
+#endif		 
+     if(flash_sect_protect (0, erase_addr1, erase_addr2-1))
+	     {
+		      printf("protect off error!\n");
+		 }
+									 
+     if (flash_sect_erase (erase_addr1, erase_addr2-1))
+	     {
+		       printf("erase error!\n");
+		 }
+									  
+	 rcode = flash_sect_erase(erase_addr1, erase_addr2-1);
+
+    
+     memcpy ((u8*)buffer,&ddr_magic,4);
+	 memcpy ((u8*)(buffer+1),(u8*)0xbe1a5f10,16);
+	 ecc=(*(u32*)0xbe1a5f10)^(*(u32*)0xbe1a5f14)^(*(u32*)0xbe1a5f18)^(*(u32*)0xbe1a5f1c);
+	 memcpy ((u8*)(buffer+5),&ecc,4);
+
+	 flash_write((char *)buffer, IFX_CFG_FLASH_DDR_CFG_START_ADDR, 24);/*one magic word,4 parameters,1cc,24bytes*/
+
+	 //(void) flash_sect_protect (1, erase_addr1, erase_addr2-1);
+										
+     return;
+}
+#elif CONFIG_BOOT_FROM_NAND
+void save_ddr_param(void)
+{
+	 return;
+}
+#elif CONFIG_BOOT_FROM_SPI
+void save_ddr_param(void)
+{
+	 int rcode;
+	 ulong   ddr_magic=0x88888888;
+	 ulong erase_addr1=0, erase_addr2=0;
+	 volatile ulong* ptr=IFX_CFG_FLASH_DDR_CFG_START_ADDR;
+	 ulong  ecc;
+	 ulong  buffer[6];
+	 static struct spi_flash *flash_spi;
+	 flash_spi = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+            CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	
+	 erase_addr1 = IFX_CFG_FLASH_DDR_CFG_START_ADDR; 
+	 erase_addr2 = IFX_CFG_FLASH_DDR_CFG_START_ADDR + IFX_CFG_FLASH_DDR_CFG_SIZE;
+	 if(*(u32*)0xbe1a5f20!=0x2)  /*0xBE1A5F20 contains the tuning status*/
+	    {
+		    /*no new parameter, return immediately*/
+		    return;
+	    }
+	 
+	 memcpy ((u8*)buffer,&ddr_magic,4);
+	 memcpy ((u8*)(buffer+1),(u8*)0xbe1a5f10,16);
+	 ecc=(*(u32*)0xbe1a5f10)^(*(u32*)0xbe1a5f14)^(*(u32*)0xbe1a5f18)^(*(u32*)0xbe1a5f1c);
+	 memcpy ((u8*)(buffer+5),&ecc,4);  
+	 spi_flash_write(flash_spi, erase_addr1, 24, (char *)buffer);   
+	 printf("saved ddr param in flash!\n");    
+	    
+   return;
+}
+#endif
+#endif
+
+
+phys_size_t initdram(int board_type)
+{
+    return (1024*1024*CONFIG_IFX_MEMORY_SIZE);
+}
+	
+
+int checkboard (void)
+{
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+   if (danube_eth_init(bis)<0)
+            return -1;
+
+    return 0;
+}
+						 
+int board_early_init_f(void)
+{
+       (*EBU_ADDR_SEL_0) = CONFIG_EBU_ADDSEL0;
+       (*EBU_CON_0) = CONFIG_EBU_BUSCON0;
+	   return 0;
+}
+				   
+
--- /dev/null
+++ b/board/danube/danube_ref_ddr166.conf
@@ -0,0 +1,134 @@
+ 0xbf800060  0x7
+ 0xbf800010  0x0
+ 0xbf800020  0x0
+ 0xbf800200  0x02
+ 0xbf800210  0x0
+
+;REG32(MC_DC0) = 0x00001B1B;
+ 0xbf801000  0x1b1b
+;REG32(MC_DC1) = 0x00000000;
+ 0xbf801010  0x0
+;REG32(MC_DC2) = 0x00000000;
+ 0xbf801020  0x0
+;REG32(MC_DC3) = 0x00000000;
+ 0xbf801030  0x0
+;REG32(MC_DC4) = 0x00000000;
+ 0xbf801040  0x0
+;REG32(MC_DC5) = 0x00000200;
+ 0xbf801050  0x200
+;REG32(MC_DC6) = 0x00000306;
+; 0xbf801060  0x0306
+ 0xbf801060  0x0605
+;REG32(MC_DC7) = 0x00000303;
+ 0xbf801070  0x302
+; 0xbf801070  0x0203
+;REG32(MC_DC8) = 0x00000102;
+ 0xbf801080  0x102
+;REG32(MC_DC9) = 0x0000070A;
+ 0xbf801090  0x70a
+; 0xbf801090  0x608
+;REG32(MC_DC10) = 0x00000203;
+ 0xbf8010a0  0x203
+;REG32(MC_DC11) = 0x00000C02;
+ 0xbf8010b0  0xc02
+; 0xbf8010b0  0x0a02
+;REG32(MC_DC12) = 0x000001C8;
+ 0xbf8010c0  0x1c8
+;REG32(MC_DC13) = 0x00000001;
+ 0xbf8010d0  0x1
+;REG32(MC_DC14) = 0x00000000;
+ 0xbf8010e0  0x0
+;REG32(MC_DC15) = 0x00000F5F;
+; 0xbf8010f0  0xf5f
+ 0xbf8010f0  0xf3c
+;REG32(MC_DC16) = 0x0000C800;
+ 0xbf801100  0xc800
+;REG32(MC_DC17) = 0x0000000D; 
+; 0xbf801110  0xd
+ 0xbf801110  0xd
+;REG32(MC_DC18) = 0x00000300;
+ 0xbf801120  0x300
+;REG32(MC_DC19) = 0x00000300;
+; 0xbf801130  0x300
+ 0xbf801130  0x200
+;REG32(MC_DC20) = 0x00000A04;
+; 0xbf801140  0xa04
+ 0xbf801140  0xa04
+;REG32(MC_DC21) = 0x00001c00;
+ 0xbf801150  0xd00
+; 0xbf801150  0x1f00
+;REG32(MC_DC22) = 0x00001E1E;
+ 0xbf801160  0xd0d
+; 0xbf801160  0x1f1f
+;REG32(MC_DC23) = 0x00000000;
+ 0xbf801170  0x0
+;//Disable ECC
+;REG32(MC_DC24) = 0x0000007F;
+; 0xbf801180  0x7f
+ 0xbf801180  0x062
+; 0xbf801180  0x37f
+;REG32(MC_DC25) = 0x00000000;
+ 0xbf801190  0x0
+;REG32(MC_DC26) = 0x00000000;
+ 0xbf8011a0  0x0
+;REG32(MC_DC27) = 0x00000000;
+ 0xbf8011b0  0x0
+;REG32(MC_DC28) = 0x00000A24;
+; 0xbf8011c0  0xa24
+ 0xbf8011c0  0x510
+;REG32(MC_DC29) = 0x00002D89;
+ 0xbf8011d0  0x2d89
+; 0xbf8011d0  0x2d92
+;REG32(MC_DC30) = 0x00000022;
+ 0xbf8011e0  0x8300
+; 0xbf8011e0  0x8235
+;REG32(MC_DC31) = 0x00000000;
+ 0xbf8011f0  0x0
+;REG32(MC_DC32) = 0x00000000;
+ 0xbf801200  0x0
+;REG32(MC_DC33) = 0x00000000;
+ 0xbf801210  0x0
+;REG32(MC_DC34) = 0x00000000;
+ 0xbf801220  0x0
+;REG32(MC_DC35) = 0x00000000;
+ 0xbf801230  0x0
+;REG32(MC_DC36) = 0x00000000;
+ 0xbf801240  0x0
+;REG32(MC_DC37) = 0x00000000;
+ 0xbf801250  0x0
+;REG32(MC_DC38) = 0x00000000;
+ 0xbf801260  0x0
+;REG32(MC_DC39) = 0x00000000;
+ 0xbf801270  0x0
+;REG32(MC_DC40) = 0x00000000;
+ 0xbf801280  0x0
+;REG32(MC_DC41) = 0x00000000;
+ 0xbf801290  0x0
+;REG32(MC_DC42) = 0x00000000;
+ 0xbf8012a0  0x0
+;REG32(MC_DC43) = 0x00000000;
+ 0xbf8012b0  0x0
+;REG32(MC_DC44) = 0x00000000;
+ 0xbf8012c0  0x0
+;REG32(MC_DC45) = 0x00000600;
+ 0xbf8012d0  0x500
+;REG32(MC_DC46) = 0x00000000;
+ 0xbf8012e0  0x0
+
+ 0xbf800060  0x05
+ 0xbf801030  0x100
+ 0xbf800071  0x0c
+
+
+
+
+
+
+
+
+
+
+
+
+
+
--- /dev/null
+++ b/board/danube/ddr_settings_111.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_PROMOSDDR400.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xa02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x0
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1200
+#define MC_DC22_VALUE	0x1212
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x4e20
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_Samsung_166.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Samsung DDR K4H561638H Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x120  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1400
+#define MC_DC22_VALUE	0x1414
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x4e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d93
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_e111.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_e166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Eval Board DDR 167 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1800
+#define MC_DC22_VALUE	0x1818
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_etron166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM ETRON EM6AA160TSA controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x204
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x400
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0xd00
+#define MC_DC22_VALUE	0xd0d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x4dd1
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_psc_166.h
@@ -0,0 +1,51 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for PSC DDR A2S56D40CTP for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 27th Nov 2006 */
+
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x120  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x301
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1700
+#define MC_DC22_VALUE	0x1717
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x52   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x4e20
+#define MC_DC30_VALUE	0x8235
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_r111.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0x1200
+#define MC_DC22_VALUE	0x1212
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x5e   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/ddr_settings_r166.h
@@ -0,0 +1,50 @@
+/* Settings for Denali DDR SDRAM controller */
+/* Optimise for Danube Ref Board DDR 166 Mhz - by Ng Aik Ann 29th April */
+#define MC_DC0_VALUE	0x1B1B
+#define MC_DC1_VALUE	0x0
+#define MC_DC2_VALUE	0x0
+#define MC_DC3_VALUE	0x0
+#define MC_DC4_VALUE	0x0
+#define MC_DC5_VALUE	0x200
+#define MC_DC6_VALUE	0x605
+#define MC_DC7_VALUE	0x303
+#define MC_DC8_VALUE	0x102
+#define MC_DC9_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13c  /* WDQS tuning for clk_wr*/
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04  /* A04 for reference board, A03 for Eval board */
+#define MC_DC21_VALUE	0xd00
+#define MC_DC22_VALUE	0xd0d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62   /* WDQS Tuning for DQS */
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+//#define MC_DC45_VALUE	0x400
+#define MC_DC46_VALUE	0x0
--- /dev/null
+++ b/board/danube/lowlevel_init.S
@@ -0,0 +1,625 @@
+
+/*
+ *  Memory sub-system initialization code for INCA-IP2 development board.
+ *  Andre Messerschmidt
+ *  Copyright (c) 2005	Infineon Technologies AG 
+ *
+ *  Based on Inca-IP code 
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/* History:
+      peng liu May 25, 2006, for PLL setting after reset, 05252006
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <configs/danube.h>
+
+#ifdef CONFIG_DANUBE_PROMOS_RAM
+#include "ddr_settings_PROMOSDDR400.h"
+#elif defined(CONFIG_DANUBE_SAMSUNG_RAM)
+#include "ddr_settings_Samsung_166.h"
+#elif defined(CONFIG_DANUBE_PSC_RAM)
+#include "ddr_settings_psc_166.h"
+#elif defined(CONFIG_DANUBE_ETRON_RAM)
+#include "ddr_settings_etron166.h"
+#else /*CONFIG_DANUBE_QIMONDA_RAM*/
+#include "ddr_settings_r166.h"
+#endif
+
+
+
+
+/*TODO: liupeng check !!! */
+#define EBU_MODUL_BASE		0xB4102000
+#define EBU_CLC(value)		0x0000(value)
+#define EBU_CON(value)		0x0010(value)
+#define EBU_ADDSEL0(value)	0x0020(value)
+#define EBU_ADDSEL1(value)	0x0024(value)
+#define EBU_ADDSEL2(value)	0x0028(value)
+#define EBU_ADDSEL3(value)	0x002C(value)
+#define EBU_BUSCON0(value)	0x0060(value)
+#define EBU_BUSCON1(value)	0x0064(value)
+#define EBU_BUSCON2(value)	0x0068(value)
+#define EBU_BUSCON3(value)	0x006C(value)
+
+#define MC_MODUL_BASE		0xBF800000
+#define MC_ERRCAUSE(value)	0x0010(value)
+#define MC_ERRADDR(value)	0x0020(value)
+#define MC_CON(value)		0x0060(value)
+
+#define MC_SRAM_ENABLE		0x00000004
+#define MC_SDRAM_ENABLE		0x00000002
+#define MC_DDRRAM_ENABLE	0x00000001
+
+#define MC_SDR_MODUL_BASE	0xBF800200
+#define MC_IOGP(value)		0x0000(value)
+#define MC_CTRLENA(value)	0x0010(value)
+#define MC_MRSCODE(value)	0x0020(value)
+#define MC_CFGDW(value)		0x0030(value)
+#define MC_CFGPB0(value)	0x0040(value)
+#define MC_LATENCY(value)	0x0080(value)
+#define MC_TREFRESH(value)	0x0090(value)
+#define MC_SELFRFSH(value)	0x00A0(value)
+
+#define MC_DDR_MODUL_BASE	0xBF801000
+#define MC_DC00(value)		0x0000(value)
+#define MC_DC01(value)		0x0010(value)
+#define MC_DC02(value)		0x0020(value)
+#define MC_DC03(value)		0x0030(value)
+#define MC_DC04(value)		0x0040(value)
+#define MC_DC05(value)		0x0050(value)
+#define MC_DC06(value)		0x0060(value)
+#define MC_DC07(value)		0x0070(value)
+#define MC_DC08(value)		0x0080(value)
+#define MC_DC09(value)		0x0090(value)
+#define MC_DC10(value)		0x00A0(value)
+#define MC_DC11(value)		0x00B0(value)
+#define MC_DC12(value)		0x00C0(value)
+#define MC_DC13(value)		0x00D0(value)
+#define MC_DC14(value)		0x00E0(value)
+#define MC_DC15(value)		0x00F0(value)
+#define MC_DC16(value)		0x0100(value)
+#define MC_DC17(value)		0x0110(value)
+#define MC_DC18(value)		0x0120(value)
+#define MC_DC19(value)		0x0130(value)
+#define MC_DC20(value)		0x0140(value)
+#define MC_DC21(value)		0x0150(value)
+#define MC_DC22(value)		0x0160(value)
+#define MC_DC23(value)		0x0170(value)
+#define MC_DC24(value)		0x0180(value)
+#define MC_DC25(value)		0x0190(value)
+#define MC_DC26(value)		0x01A0(value)
+#define MC_DC27(value)		0x01B0(value)
+#define MC_DC28(value)		0x01C0(value)
+#define MC_DC29(value)		0x01D0(value)
+#define MC_DC30(value)		0x01E0(value)
+#define MC_DC31(value)		0x01F0(value)
+#define MC_DC32(value)		0x0200(value)
+#define MC_DC33(value)		0x0210(value)
+#define MC_DC34(value)		0x0220(value)
+#define MC_DC35(value)		0x0230(value)
+#define MC_DC36(value)		0x0240(value)
+#define MC_DC37(value)		0x0250(value)
+#define MC_DC38(value)		0x0260(value)
+#define MC_DC39(value)		0x0270(value)
+#define MC_DC40(value)		0x0280(value)
+#define MC_DC41(value)		0x0290(value)
+#define MC_DC42(value)		0x02A0(value)
+#define MC_DC43(value)		0x02B0(value)
+#define MC_DC44(value)		0x02C0(value)
+#define MC_DC45(value)		0x02D0(value)
+#define MC_DC46(value)		0x02E0(value)
+
+#define RCU_OFFSET  0xBF203000
+#define RCU_RST_REQ      (RCU_OFFSET + 0x0010)
+#define RCU_STS          (RCU_OFFSET + 0x0014)
+
+#define CGU_OFFSET  0xBF103000
+#define  PLL0_CFG     (CGU_OFFSET + 0x0004)
+#define  PLL1_CFG     (CGU_OFFSET + 0x0008)
+#define  PLL2_CFG     (CGU_OFFSET + 0x000C)
+#define  CGU_SYS      (CGU_OFFSET + 0x0010)
+#define  CGU_UPDATE   (CGU_OFFSET + 0x0014)
+#define  IF_CLK       (CGU_OFFSET + 0x0018)
+#define  CGU_SMD      (CGU_OFFSET + 0x0020)
+#define  CGU_CT1SR    (CGU_OFFSET + 0x0028)
+#define  CGU_CT2SR    (CGU_OFFSET + 0x002C)
+#define  CGU_PCMCR    (CGU_OFFSET + 0x0030)
+#define  PCI_CR_PCI   (CGU_OFFSET + 0x0034)
+#define  CGU_OSC_CTRL (CGU_OFFSET + 0x001C)
+#define  CGU_MIPS_PWR_DWN (CGU_OFFSET + 0x0038)
+#define  CLK_MEASURE  (CGU_OFFSET + 0x003C)
+
+//05252006
+#define  pll0_35MHz_CONFIG 0x9D861059
+#define  pll1_35MHz_CONFIG 0x1A260CD9
+#define  pll2_35MHz_CONFIG 0x8000f1e5
+#define  pll0_36MHz_CONFIG 0x1000125D 
+#define  pll1_36MHz_CONFIG 0x1B1E0C99
+#define  pll2_36MHz_CONFIG 0x8002f2a1 
+//05252006
+
+//06063001-joelin disable the PCI CFRAME mask -start
+/*CFRAME is an I/O signal, in the chip, the output CFRAME is selected via GPIO altsel pins, so if you select MII1 RXD1, the CFRAME will not come out.
+But the CFRAME input still take the signal from the pad and not disabled when altsel choose other function. So when MII1_RXD1 is low from other device, the EBU interface will be disabled.
+
+The chip function in such a way that disable the CFRAME mask mean EBU not longer check CFRAME to be the device using the bus.
+The side effect is the entire PCI block will see CFRAME low all the time meaning PCI cannot use the bus at all so no more PCI function.
+*/
+#define PCI_CR_PR_OFFSET  0xBE105400
+#define PCI_CR_PCI_MOD_REG          (PCI_CR_PR_OFFSET + 0x0030)
+#define PCI_CONFIG_SPACE  0xB7000000
+#define CS_CFM		(PCI_CONFIG_SPACE + 0x6C)
+//06063001-joelin disable the PCI CFRAME mask -end
+	.set	noreorder
+
+
+/*
+ * void ebu_init(long)
+ *
+ * a0 has the clock value we are going to run at
+ */
+	.globl	ebu_init
+	.ent	ebu_init
+ebu_init:
+/*TODO:liupeng */
+	j	ra
+	nop
+
+	.end	ebu_init
+
+
+/*
+ * void cgu_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	cgu_init
+	.ent	cgu_init
+cgu_init:
+	li  t2, CGU_SYS
+  lw  t2,0(t2)
+  beq t2,a0,freq_up2date
+  nop
+
+	li  t2, RCU_STS
+	lw  t2, 0(t2)
+	and t2,0x00020000
+	beq t2,0x00020000,boot_36MHZ
+  nop
+//05252006
+	li  t1, PLL0_CFG
+	li  t2, pll0_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_35MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+	b   wait_reset
+	nop
+boot_36MHZ:
+	li  t1, PLL0_CFG
+	li  t2, pll0_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL1_CFG
+	li  t2, pll1_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, PLL2_CFG
+	li  t2, pll2_36MHz_CONFIG
+	sw	t2,0(t1)
+	li  t1, CGU_SYS
+	sw	a0,0(t1)
+    /*enable DDR PAD Class II*/
+    li  t1, CGU_SMD
+    li  a0, 0x200000
+    sw  a0, 0(t1)      // Turn on DDR PAD Class II to INC drive.
+    /*************************/
+
+	li  t1, RCU_RST_REQ
+	li  t2, 0x40000008
+	sw	t2,0(t1)
+//05252006
+
+wait_reset:
+    b   wait_reset
+    nop
+freq_up2date:
+    j ra 
+    nop
+	.end	cgu_init
+
+
+/*
+ * void sdram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	sdram_init
+	.ent	sdram_init
+sdram_init:
+	
+	/* SDRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+	
+	/* Enable SDRAM module in memory controller */
+	li	t3, MC_SDRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+	
+	li	t1, MC_SDR_MODUL_BASE
+	
+	/* disable the controller */
+	li	t2, 0
+	sw	t2, MC_CTRLENA(t1)
+     
+	li	t2, 0x822	
+	sw	t2, MC_IOGP(t1)
+
+	li	t2, 0x2
+	sw	t2, MC_CFGDW(t1)
+	
+	/* Set CAS Latency */
+	li	t2, 0x00000020		
+	sw	t2, MC_MRSCODE(t1)
+	
+	/* Set CS0 to SDRAM parameters */
+	li	t2, 0x000014d8
+	sw	t2, MC_CFGPB0(t1)
+	
+	/* Set SDRAM latency parameters */
+	li  	t2, 0x00036325;   /* BC PC100 */
+	sw	t2, MC_LATENCY(t1)
+	
+	/* Set SDRAM refresh rate */
+	li	t2, 0x00000C30		
+	sw	t2, MC_TREFRESH(t1)
+	
+	/* Clear Power-down registers */
+	sw	zero, MC_SELFRFSH(t1)
+
+	/* Finally enable the controller */
+	li	t2, 1
+	sw	t2, MC_CTRLENA(t1)
+
+	
+	j	ra
+	nop
+
+
+	.end	sdram_init
+
+
+
+/*
+ * void ddrram_init(long)
+ *
+ * a0 has the clock value
+ */
+	.globl	ddrram_init
+	.ent	ddrram_init
+ddrram_init:
+
+	/* DDR-DRAM Initialization
+	 */
+	li	t1, MC_MODUL_BASE
+
+	/* Clear Error log registers */
+	sw	zero, MC_ERRCAUSE(t1)
+	sw	zero, MC_ERRADDR(t1)
+	
+	/* Enable DDR module in memory controller */
+	li	t3, MC_DDRRAM_ENABLE
+	lw	t2, MC_CON(t1)
+	or	t3, t2, t3
+	sw	t3, MC_CON(t1)
+	
+	li	t1, MC_DDR_MODUL_BASE
+	
+    /* Write configuration to DDR controller registers */
+	li	t2, MC_DC0_VALUE
+	sw	t2, MC_DC00(t1)
+     
+	li	t2, MC_DC1_VALUE
+	sw	t2, MC_DC01(t1)
+
+	li	t2, MC_DC2_VALUE
+	sw	t2, MC_DC02(t1)
+
+	li	t2, MC_DC3_VALUE
+	sw	t2, MC_DC03(t1)
+
+	li	t2, MC_DC4_VALUE
+	sw	t2, MC_DC04(t1)
+
+	li	t2, MC_DC5_VALUE
+	sw	t2, MC_DC05(t1)
+
+	li	t2, MC_DC6_VALUE
+	sw	t2, MC_DC06(t1)
+	
+	li	t2, MC_DC7_VALUE
+	sw	t2, MC_DC07(t1)
+	
+	li	t2, MC_DC8_VALUE
+	sw	t2, MC_DC08(t1)
+	
+	li	t2, MC_DC9_VALUE
+	sw	t2, MC_DC09(t1)
+	
+	li	t2, MC_DC10_VALUE
+	sw	t2, MC_DC10(t1)
+
+	li	t2, MC_DC11_VALUE
+	sw	t2, MC_DC11(t1)
+
+	li	t2, MC_DC12_VALUE
+	sw	t2, MC_DC12(t1)
+
+	li	t2, MC_DC13_VALUE
+	sw	t2, MC_DC13(t1)
+
+	li	t2, MC_DC14_VALUE
+	sw	t2, MC_DC14(t1)
+
+	li	t2, MC_DC15_VALUE
+	sw	t2, MC_DC15(t1)
+
+	li	t2, MC_DC16_VALUE
+	sw	t2, MC_DC16(t1)
+
+	li	t2, MC_DC17_VALUE
+	sw	t2, MC_DC17(t1)
+
+	li	t2, MC_DC18_VALUE
+	sw	t2, MC_DC18(t1)
+
+	li	t2, MC_DC19_VALUE
+	sw	t2, MC_DC19(t1)
+
+	li	t2, MC_DC20_VALUE
+	sw	t2, MC_DC20(t1)
+
+	li	t2, MC_DC21_VALUE
+	sw	t2, MC_DC21(t1)
+
+	li	t2, MC_DC22_VALUE
+	sw	t2, MC_DC22(t1)
+
+	li	t2, MC_DC23_VALUE
+	sw	t2, MC_DC23(t1)
+
+	li	t2, MC_DC24_VALUE
+	sw	t2, MC_DC24(t1)
+
+	li	t2, MC_DC25_VALUE
+	sw	t2, MC_DC25(t1)
+
+	li	t2, MC_DC26_VALUE
+	sw	t2, MC_DC26(t1)
+
+	li	t2, MC_DC27_VALUE
+	sw	t2, MC_DC27(t1)
+
+	li	t2, MC_DC28_VALUE
+	sw	t2, MC_DC28(t1)
+
+	li	t2, MC_DC29_VALUE
+	sw	t2, MC_DC29(t1)
+
+	li	t2, MC_DC30_VALUE
+	sw	t2, MC_DC30(t1)
+
+	li	t2, MC_DC31_VALUE
+	sw	t2, MC_DC31(t1)
+
+	li	t2, MC_DC32_VALUE
+	sw	t2, MC_DC32(t1)
+
+	li	t2, MC_DC33_VALUE
+	sw	t2, MC_DC33(t1)
+
+	li	t2, MC_DC34_VALUE
+	sw	t2, MC_DC34(t1)
+
+	li	t2, MC_DC35_VALUE
+	sw	t2, MC_DC35(t1)
+
+	li	t2, MC_DC36_VALUE
+	sw	t2, MC_DC36(t1)
+
+	li	t2, MC_DC37_VALUE
+	sw	t2, MC_DC37(t1)
+
+	li	t2, MC_DC38_VALUE
+	sw	t2, MC_DC38(t1)
+
+	li	t2, MC_DC39_VALUE
+	sw	t2, MC_DC39(t1)
+
+	li	t2, MC_DC40_VALUE
+	sw	t2, MC_DC40(t1)
+
+	li	t2, MC_DC41_VALUE
+	sw	t2, MC_DC41(t1)
+
+	li	t2, MC_DC42_VALUE
+	sw	t2, MC_DC42(t1)
+
+	li	t2, MC_DC43_VALUE
+	sw	t2, MC_DC43(t1)
+
+	li	t2, MC_DC44_VALUE
+	sw	t2, MC_DC44(t1)
+    
+	li	t2, MC_DC45_VALUE
+	sw	t2, MC_DC45(t1)
+
+	li	t2, MC_DC46_VALUE
+	sw	t2, MC_DC46(t1)
+
+#ifdef CONFIG_TUNE_DDR
+    li      t3, IFX_CFG_FLASH_DDR_CFG_START_ADDR 
+    lw      t4, 0(t3)
+	li      t3, 0x88888888
+	bne     t3, t4, ddr_not_configured
+	nop
+    /*calculate the crc value*/
+	li      t3, IFX_CFG_FLASH_DDR_CFG_START_ADDR
+	addi    t3, t3, 0x4 
+	lw      t4, 0(t3)
+	lw      t5, 4(t3)
+	xor     t4, t4, t5
+	lw      t5, 8(t3)
+	xor     t4, t4, t5
+	lw      t5, 0xc(t3)
+	xor     t4, t4, t5
+	lw      t5, 0x10(t3)
+	bne     t4, t5, ddr_not_configured
+	nop
+    /*crc correct, load the stored value*/
+	li      t2, IFX_CFG_FLASH_DDR_CFG_START_ADDR
+	addi    t2, t2, 0x04
+	lw      t2, 0(t2)
+	sw      t2, MC_DC15(t1)
+
+	li      t2, IFX_CFG_FLASH_DDR_CFG_START_ADDR
+	addi    t2, t2, 0x08
+	lw      t2, 0(t2)
+	sw      t2, MC_DC21(t1)
+
+	li      t2, IFX_CFG_FLASH_DDR_CFG_START_ADDR
+	addi    t2, t2, 0x0c
+	lw      t2, 0(t2)
+	sw      t2, MC_DC22(t1)
+
+	li      t2, IFX_CFG_FLASH_DDR_CFG_START_ADDR
+	addi    t2, t2, 0x10
+	lw  	t2, 0(t2)
+	sw      t2, MC_DC24(t1)
+	
+	/*ddr use stored value, put 0 in 0xbe1a7f20*/
+	li      t3, 0xBe1a5f20
+	li      t4, 0x0
+	sw      t4, 0(t3)
+
+	b       2f
+	nop
+
+ddr_not_configured:
+    li      t2, 0
+	sw      t2, MC_DC21(t1)
+
+	li      t2, 0
+	sw      t2, MC_DC22(t1)
+
+	/*ddr not configured, put 0xff in 0xbe1a5f20*/
+	li      t3, 0xBe1a5f20
+	li      t4, 0xff
+	sw      t4, 0(t3)
+
+#endif
+2:
+	li	    t2, 0x00000100
+	sw	    t2, MC_DC03(t1)
+
+    li      t1, 0xbf800070 /*memory controller status register*/
+	li      t3, 0x08
+1:
+    lw      t2,0(t1)
+	and     t2,t3
+	bne     t2,t3,1b       /*check for DDR DLL LOCK*/
+	nop
+				
+	j	ra
+	nop
+	.end	ddrram_init
+
+	.globl	lowlevel_init
+	.ent	lowlevel_init
+lowlevel_init:
+
+    /* EBU, CGU and SDRAM/DDR-RAM Initialization.
+	 */
+	move	t0, ra
+	/* We rely on the fact that neither cgu_init() nor sdram_init()
+	 * modify t0
+	 */
+  /* 0xe8 means CPU0/CPU1 333M, DDR 167M, FPI 83M, PPE 240M */
+        li  a0,0xe8
+#ifdef  DANUBE_DDR_RAM_133M
+    li  a0,0xe9
+#endif
+
+        bal cgu_init
+        nop
+
+//06063001-joelin disable the PCI CFRAME mask-start
+#ifdef DISABLE_CFRAME
+	li  t1, PCI_CR_PCI	//mw bf103034 80000000
+	li  t2, 0x80000000
+	sw	t2,0(t1)
+
+	li  t1, PCI_CR_PCI_MOD_REG	//mw be105430 103
+	li  t2, 0x103
+	sw  t2,0(t1)
+	
+	li  t1, CS_CFM			//mw b700006c 0 
+	li  t2, 0x00
+	sw  t2, 0(t1)		
+	
+	li  t1, PCI_CR_PCI_MOD_REG	//mw be105430 103
+	li  t2, 0x1000103
+	sw  t2, 0(t1)	
+#endif 
+//06063001-joelin disable the PCI CFRAME mask-end
+
+
+#ifdef  CONFIG_BOOT_FROM_NOR 	
+#ifdef CONFIG_TUNE_DDR
+  li      t1, 0xbf800060
+	lw      t2, 0(t1)
+	andi    t2, t2, 0x1
+	bne     t2, zero, ddr_init_finish
+	nop
+#endif
+  bal	ddrram_init
+	nop
+#endif
+ddr_init_finish:
+	move	ra, t0
+	j	ra
+	nop
+
+	.end	lowlevel_init
--- /dev/null
+++ b/board/danube/u-boot.lds
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	. = ALIGN(16);
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+    got_size = (__got_end - __got_start);
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+        . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
--- /dev/null
+++ b/include/configs/danube.h
@@ -0,0 +1,240 @@
+/*
+ * (C) Copyright 2003-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the AR9 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/autoconf.h>
+#include <configs/lq_cfg.h>
+#include <asm/danube.h>
+
+
+#ifdef CONFIG_CPU_111M_RAM_111M
+#define CPU_CLOCK_RATE          111000000   /* 111 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          111000000   /* 111 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_166M_RAM_166M)
+#define CPU_CLOCK_RATE          166000000   /* 166 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          166000000   /* 166 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_333M_RAM_111M)
+#define CPU_CLOCK_RATE          333000000   /* 333 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          111000000   /* 111 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_333M_RAM_166M)
+#define CPU_CLOCK_RATE          333000000   /* 333 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          166000000   /* 166 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_393M_RAM_196M)
+#define CPU_CLOCK_RATE          393000000   /* 393 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          196000000   /* 196 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_442M_RAM_221M)
+#define CPU_CLOCK_RATE          442000000   /* 442 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          221000000   /* 221 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_442M_RAM_147M)
+#define CPU_CLOCK_RATE          442000000   /* 442 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          147000000   /* 147 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_500M_RAM_166M)
+#define CPU_CLOCK_RATE          500000000   /* 500 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          166000000   /* 166 MHz clock for RAM           */
+#elif defined(CONFIG_CPU_500M_RAM_250M)
+#define CPU_CLOCK_RATE          500000000   /* 500 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          250000000   /* 250 MHz clock for RAM           */
+#endif
+
+
+#define F_SSC_CLK  get_ssc_clk()
+#define CONFIG_SYS_HZ 1000
+#define CONFIG_ENV_SPI_CS 1
+#define CONFIG_ENV_SPI_MODE CONFIG_SF_DEFAULT_MODE
+
+
+
+#ifndef	CPU_CLOCK_RATE
+/* allowed values: 100000000, 133000000, and 150000000 */
+#define CPU_CLOCK_RATE	150000000	/* default: 150 MHz clock for the MIPS core */
+#endif
+
+#define CONFIG_BAUDRATE		115200
+
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_SYS_ASC_BASE 0xbe100c00
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#define CONFIG_PREBOOT	"echo;"	\
+	"echo Type \\\"run flash_nfs\\\" to mount root filesystem over NFS;" \
+	"echo"
+
+#undef	CONFIG_BOOTARGS
+
+#define CONFIG_EXTRA_ENV_SETTINGS   <configs/lq_extra_env.h>
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory      */
+#define	CONFIG_SYS_PROMPT		"DANUBE # "	/* Monitor Command Prompt    */
+#define	CONFIG_SYS_CBSIZE		512		/* Console I/O Buffer Size   */
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)  /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		32		/* max number of command args*/
+
+#define CONFIG_SYS_MALLOC_LEN		512*1024
+
+#define CONFIG_SYS_BOOTPARAMS_LEN	256*1024
+
+#define CONFIG_SYS_MIPS_TIMER_FREQ	(danube_get_cpuclk()/2)
+
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+
+#define	CONFIG_SYS_LOAD_ADDR		0x80100000	/* default load address	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x80100000
+#define CONFIG_SYS_MEMTEST_END		0x80800000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xb0000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0xb0800000 /* Flash Bank #2 */
+
+#define CONFIG_SYS_FLASH_SWAP_ADDR
+
+#define FLASH_FIXUP_ADDR_8(addr)        ((void*)((ulong)(addr)^2))
+#define FLASH_FIXUP_ADDR_16(addr)       ((void*)((ulong)(addr)^2))
+
+#define CONFIG_SYS_FLASH_CFI_WIDTH      FLASH_CFI_16BIT
+
+#define CONFIG_EBU_ADDSEL0               0x10000031
+#define CONFIG_EBU_BUSCON0               0x0001D7FF
+
+
+/* The following #defines are needed to get flash environment right */
+#define	CONFIG_SYS_MONITOR_BASE	CONFIG_RAM_TEXT_BASE
+
+#define	CONFIG_SYS_MONITOR_LEN		(512 << 10)
+
+#define CONFIG_SYS_INIT_SP_OFFSET	0x400000
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2 * CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+
+#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	1
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_SYS_MAX_NAND_DEVICE    1
+#define CONFIG_SYS_NAND_BASE   0xb4000000
+
+#define NAND_BASE_ADDRESS  0xB4000000
+#define CFG_NAND_BASE NAND_BASE_ADDRESS
+#define NAND_WRITE(addr, val)     *((volatile u8*)(NAND_BASE_ADDRESS | (addr))) = val;while((*EBU_NAND_WAIT & 0x08) == 0);
+//#define NAND_WRITE(addr, val)     *((volatile u8*)(NAND_BASE_ADDRESS | (addr)))=val;
+#define NAND_READ(addr, val)      val = *((volatile u8*)(NAND_BASE_ADDRESS | (addr)))
+#define NAND_CE_SET         *EBU_NAND_CON   = 0x00F005F3
+#define NAND_CE_CLEAR       *EBU_NAND_CON   = 0x000005F2
+#define NAND_READY       ( ((*EBU_NAND_WAIT)&0x07) == 7)
+
+#define NAND_READY_CLEAR  *EBU_NAND_WAIT = 0;
+#define WRITE_CMD    0x18
+#define WRITE_ADDR   0x14
+#define WRITE_LADDR  0x10
+#define WRITE_DATA  0x10
+#define READ_DATA    0x10
+#define READ_LDATA   0x00
+#define ACCESS_WAIT
+#define IFX_ATC_NAND 0xc176
+#define IFX_BTC_NAND 0xc166
+#define ST_512WB2_NAND 0x2076
+#define NAND_LATCH_ENABLE 
+#define NAND_CLRALE  *EBU_NAND_CON &=~(1<<18);
+#define NAND_SETALE  *EBU_NAND_CON |=1<<18;
+#define NAND_CLRCLE  *EBU_NAND_CON &=~(1<<19);
+#define NAND_SETCLE  *EBU_NAND_CON |=1<<19;
+
+
+#define NAND_DISABLE_CE(nand) *EBU_NAND_CON = *EBU_NAND_CON & ~(1<<20);
+#define NAND_ENABLE_CE(nand)  *EBU_NAND_CON = *EBU_NAND_CON |(1<<20);
+#define NAND_WAIT_READY(nand) while(!NAND_READY){}
+#define WRITE_NAND_COMMAND(d, adr) NAND_WRITE(WRITE_CMD,d);
+#define WRITE_NAND_ADDRESS(d, adr) NAND_WRITE(WRITE_ADDR,d);
+#define WRITE_NAND(d, adr) NAND_WRITE(WRITE_DATA,d);
+#define READ_NAND(adr) *((volatile u8*)(NAND_BASE_ADDRESS | (READ_DATA)))
+#define IFX_NAND_CTL_CLRALE *EBU_NAND_CON &=~(1<<18);
+#define IFX_NAND_CTL_SETALE *EBU_NAND_CON |=1<<18;
+
+#define CONFIG_SYS_NAND_PAGE_SIZE   512 /* NAND chip page size          */
+#define CONFIG_SYS_NAND_BLOCK_SIZE  (32 << 10) /* NAND chip block size      */
+#define CONFIG_SYS_NAND_PAGE_COUNT  32  /* NAND chip page count         */
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS   5   /* Location of bad block marker */
+#undef CONFIG_SYS_NAND_4_ADDR_CYCLE     /* No fourth addr used (<=32MB) */
+
+#define CONFIG_SYS_NAND_ECCSIZE 256
+#define CONFIG_SYS_NAND_ECCBYTES    3
+#define CONFIG_SYS_NAND_ECCSTEPS    (CONFIG_SYS_NAND_PAGE_SIZE / CONFIG_SYS_NAND_ECCSIZE)
+#define CONFIG_SYS_NAND_OOBSIZE 16
+#define CONFIG_SYS_NAND_ECCTOTAL    (CONFIG_SYS_NAND_ECCBYTES * CONFIG_SYS_NAND_ECCSTEPS)
+#define CONFIG_SYS_NAND_ECCPOS      {0, 1, 2, 3, 6, 7}
+
+#define CONFIG_SYS_NAND_U_BOOT_SIZE  (512 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST   CONFIG_BOOTSTRAP_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_START CONFIG_BOOTSTRAP_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_OFFS  16384
+
+
+#ifdef CONFIG_BOOT_FROM_NOR
+#define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0xB000FFE8
+#define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+#define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0xb000ffff
+#elif defined(CONFIG_BOOT_FROM_SPI)
+#define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x0000FFE8
+#define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+#define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x0000ffff
+#define CONFIG_ENV_SECT_SIZE 0x1000
+#else /*CONFIG_BOOT_FRON_NAND*/
+#define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x00003fe8
+#define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+#define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x00003fff
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#define CONFIG_ENV_OFFSET		IFX_CFG_FLASH_UBOOT_CFG_START_ADDR
+#define CONFIG_ENV_ADDR		  IFX_CFG_FLASH_UBOOT_CFG_START_ADDR
+#define CONFIG_ENV_SIZE		  IFX_CFG_FLASH_UBOOT_CFG_SIZE
+
+#define CONFIG_TUNING_STATUS 0xBe1a5f20 
+#define CONFIG_TUNING_SP     0x9e1a5f00 
+
+#endif	/* __CONFIG_H */
--- /dev/null
+++ b/include/configs/danube_cfg.h
@@ -0,0 +1,786 @@
+/* ============================================================================
+ * Copyright (C) 2003[- 2004] ? Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ *
+ * File Name: ifx_cfg.h
+ * Author : Mars Lin (mars.lin@infineon.com)
+ * Date:
+ *
+ * ===========================================================================
+ *
+ * Project:
+ * Block:
+ *
+ * ===========================================================================
+ * Contents:  This file contains the data structures and definitions used
+ *        by the core iptables and the sip alg modules.
+ * ===========================================================================
+ * References:
+ */
+
+/*
+ * This file contains the configuration parameters for the IFX board.
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Board specific configurations
+ */
+#ifdef CONFIG_BOOT_FROM_NOR
+
+#ifdef CONFIG_NOR_FLASH_2M
+#define IFX_CONFIG_FLASH_SIZE 2
+#elif CONFIG_NOR_FLASH_4M
+#define IFX_CONFIG_FLASH_SIZE 4
+#elif CONFIG_NOR_FLASH_8M
+#define IFX_CONFIG_FLASH_SIZE 8
+#endif
+
+#ifndef IFX_CONFIG_FLASH_SIZE
+#define IFX_CONFIG_FLASH_SIZE 4
+#endif
+
+#ifdef CONFIG_FIRMWARE_IN_ROOTFS
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0xB0010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0xB01FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0xB01FB200
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0xB01FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0xB01FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0xB01FFDFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME        "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR        0xB01FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE              0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR          0xB01FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0xB01FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0xB0010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME          "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR          0xB03F6DFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0xB03ECE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0xB03FCDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0xB03FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0xB03FFDFF
+
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME         "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR         0xB03FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE               0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR           0xB03FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0xB03FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "total_part=2\0"
+
+#ifdef CONFIG_OVERLAY
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_OVERLAY_IMAGE_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block7=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=8\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block6=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=7\0"
+#endif
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+#ifdef CONFIG_OVERLAY
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB078FFFF
+#else
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB07DFFFF
+#endif
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_BLOCK_NAME          "overlay"
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_START_ADDR          0xB0790000
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_SIZE                0x50000
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_END_ADDR            0xB07DFFFF
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB07E0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB07EFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0xB07F0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0xB07F0FFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME          "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR          0xB07F1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE                0x1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR            0xB07F1FFF
+  
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME	      "calibration"
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_START_ADDR	      0xB07F2000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_SIZE		          0x1000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_END_ADDR		      0xB07F2FFF  
+
+  #define IFX_CFG_FLASH_END_ADDR                          0xB07FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#else /*Not defined CONFIG_FIRMWARE_IN_ROOTFS*/
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "part2_begin=0xB0040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0xB0010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0xB0040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0xB01FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0xB01FAE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0xB01FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0xB01FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0xB01FFDFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME        "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR        0xB01FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE              0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR          0xB01FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0xB01FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "part2_begin=0xB0040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME        "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR        0xB0010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE              0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME     "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0xB0040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME          "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR          0xB03F6DFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0xB03ECE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0xB03ECDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0xB03FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0xB0402DFF
+
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME         "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR         0xB03FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE               0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR           0xB03FFFFF
+
+
+  #define IFX_CFG_FLASH_END_ADDR                         0xB03FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0010000\0"                                      \
+        "part2_begin=0xB0050000\0"                                      \
+        "total_part=3\0"
+
+#ifdef CONFIG_OVERLAY
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_OVERLAY_IMAGE_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block6=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block7=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block8=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=9\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block7=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=8\0"
+#endif
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0xB0010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0050000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+  
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+#ifdef CONFIG_OVERLAY
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB078FFFF
+#else
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB07DFFFF
+#endif
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_BLOCK_NAME          "overlay"
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_START_ADDR          0xB0790000
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_SIZE                0x50000
+  #define IFX_CFG_FLASH_OVERLAY_IMAGE_END_ADDR            0xB07DFFFF
+
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB07E0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB07EFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0xB07F0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0xB07F0FFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME          "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR          0xB07F1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE                0x1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR            0xB07F1FFF
+  
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME	  "calibration"
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_START_ADDR	  0xB07F2000
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_SIZE		  0x1000
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_END_ADDR	  0xB07F2FFF  
+
+  #define IFX_CFG_FLASH_END_ADDR                          0xB07FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#endif /*CONFIG_FIRMWARE_IN_ROOTFS*/
+
+
+#endif /*CONFIG_BOOT_FROM_NOR*/
+
+
+/***************************************************************************/
+/***************************************************************************/
+/***************SPI FLASH map starts here***********************************/
+/***************************************************************************/
+/***************************************************************************/
+
+#ifdef CONFIG_BOOT_FROM_SPI
+
+#ifdef CONFIG_SPI_FLASH_2M
+#define IFX_CONFIG_FLASH_SIZE 2
+#elif CONFIG_SPI_FLASH_4M
+#define IFX_CONFIG_FLASH_SIZE 4
+#elif CONFIG_SPI_FLASH_8M
+#define IFX_CONFIG_FLASH_SIZE 8
+#endif
+
+#ifndef IFX_CONFIG_FLASH_SIZE
+#define IFX_CONFIG_FLASH_SIZE 4
+#endif
+
+#ifdef CONFIG_FIRMWARE_IN_ROOTFS
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001FB200
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FFDFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME        "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE              0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block6=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=7\0"
+        
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x003DFFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x003E0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x003EFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x003F0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x003F0FFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME          "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR          0x003F1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE                0x1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR            0x003F1FFF
+  
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME	      "calibration"
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_START_ADDR	      0x003F2000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_SIZE		          0x1000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_END_ADDR		      0x003F2FFF  
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "data_block6=" IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME "\0"    \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+ #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007DFFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007E0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007EFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007F0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007F0FFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME          "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR          0x007F1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE                0x1000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR            0x007F1FFF
+  
+  #define IFX_CFG_FLASH_CALIBRATION_CFG_BLOCK_NAME	      "calibration"
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_START_ADDR	      0x007F2000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_SIZE		          0x1000
+	#define IFX_CFG_FLASH_CALIBRATION_CFG_END_ADDR		      0x007F2FFF  
+
+
+  
+  #define IFX_CFG_FLASH_END_ADDR                         0x007FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#else /*Not defined CONFIG_FIRMWARE_IN_ROOTFS*/
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"  \
+  "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001FAE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FFDFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME        "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE              0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME        "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR        0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE              0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME     "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x00040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x000F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x000F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x000FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x000FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x000FEFFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME        "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR        0x000FFE00
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE              0x0200
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR          0x000FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00050000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00050000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB07EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB07FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0xB07FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0xB07FEFFF
+
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_BLOCK_NAME          "fwdiag"
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR          0xB07FF000
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE                0x400
+  #define IFX_CFG_FLASH_FIRMWARE_DIAG_END_ADDR            0xB07FF3FF
+  
+  #define IFX_CFG_FLASH_END_ADDR                          0x007FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#endif /*CONFIG_FIRMWARE_IN_ROOTFS*/
+
+
+#endif /*CONFIG_BOOT_FROM_SPI*/
+/* End of Board specific configurations
+ *-----------------------------------------------------------------------
+ */
+
+/*************************************************************************/
+
