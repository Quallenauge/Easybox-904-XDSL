# HG changeset patch
# Parent 4b88d80fa8cf00a1006422f5d4dacb17675bb4fa
Add lib_bootstrap

--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.c
@@ -0,0 +1,621 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+#include <config.h>
+
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { return result; } \
+  BufferLim = Buffer + size; if (size == 0) { return LZMA_RESULT_DATA_ERROR; } }}
+#endif
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+#else
+#define RC_TEST { if (Buffer == BufferLim) { return LZMA_RESULT_DATA_ERROR; } }
+#endif
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+			  
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+              return LZMA_RESULT_DATA_ERROR;
+            }
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+		
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
--- /dev/null
+++ b/lib_bootstrap/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
--- /dev/null
+++ b/lib_bootstrap/LzmaWrapper.c
@@ -0,0 +1,226 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+//#define DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+
+static size_t rpos=0, dpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+  asm("sync");  
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  if (sizeof(UInt32) < 4)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("LZMA decoder needs correct UInt32\n");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big compressed stream\n");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+  asm("sync");
+
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantReadMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("%s\n", kCantReadMessage);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    if (waitEOS)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Stream with EOS marker is not supported");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big uncompressed stream");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("Incorrect stream properties");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0 
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantAllocateMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  {
+    SizeT inProcessed;
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("\nDecoding error = %d\n", res);
+#endif
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
--- /dev/null
+++ b/lib_bootstrap/LzmaWrapper.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.h
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#ifndef  __LZMA_WRAPPER_H__
+#define  __LZMA_WRAPPER_H__
+
+#ifndef LZMA_RESULT_OK
+#define LZMA_RESULT_OK 0
+#endif
+#ifndef LZMA_RESULT_DATA_ERROR
+#define LZMA_RESULT_DATA_ERROR 1
+#endif
+
+extern int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len);
+
+#endif /*__LZMA_WRAPPER_H__*/
--- /dev/null
+++ b/lib_bootstrap/Makefile
@@ -0,0 +1,60 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= libbootstrap.a
+
+ifdef CONFIG_LANTIQ_UBOOT_amazon_se
+  OBJS  = bootstrap_board.o
+else
+  ifdef CONFIG_BOOT_FROM_NOR
+  OBJS	= bootstrap_board.o  
+  else
+  OBJS    = nand_spl_board.o 
+  endif
+endif
+
+OBJS +=LzmaDecode.o LzmaWrapper.o
+
+ifdef CONFIG_BOOT_FROM_NOR
+ifdef CONFIG_TUNE_DDR
+OBJS += tune_ddr.o
+endif
+endif
+
+all: .depend $(LIB)
+
+bootstrap: .depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
--- /dev/null
+++ b/lib_bootstrap/bootstrap_board.c
@@ -0,0 +1,337 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+//#include <malloc.h>
+#include <stdio_dev.h>
+#include <timestamp.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDec.h>
+#include <lzma/LzmaTools.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define	TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
+
+#undef DEBUG
+
+#define REG32(addr)           *((volatile u32 *)(addr))
+
+extern ulong uboot_end_data;
+extern ulong uboot_end;
+
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+void mem_malloc_init(ulong start, ulong size)
+{
+	 mem_malloc_end = start + size;
+   mem_malloc_start = start;
+   mem_malloc_brk = start;
+
+   memset ((void *) mem_malloc_start,
+        0,
+       mem_malloc_end - mem_malloc_start);
+	  
+}
+
+void *malloc(unsigned int size)
+{
+    if(size < (mem_malloc_end - mem_malloc_start))
+    {
+        mem_malloc_start += size;
+        return (void *)(mem_malloc_start - size);
+    }
+    return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+    return NULL;
+}
+
+void free(void *src)
+{
+    return;
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+    ulong old = mem_malloc_brk;
+    ulong new = old + increment;
+
+    if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+        return (NULL);
+    }
+    mem_malloc_brk = new;
+    return ((void *) old);
+}
+
+
+
+static int init_func_ram (void)
+{
+	
+	gd->ram_size =(1024*1024*CONFIG_IFX_MEMORY_SIZE);
+    return (0);
+
+}
+
+
+int checkboard (void)
+{
+     ulong addr, addr_sp;
+    
+#ifdef CONFIG_TUNE_DDR
+  #ifdef CONFIG_BOOT_FROM_NOR
+   if(REG32(CONFIG_TUNING_STATUS)==0x0 ||REG32(CONFIG_TUNING_STATUS)==0x1 || REG32(CONFIG_TUNING_STATUS)==0x2){
+       return 0; /*already tuned, return*/
+    }
+   else{
+   /*not tuned, ddr need to be tuned*/
+   addr_sp=CONFIG_TUNING_SP;
+   addr=CONFIG_DDR_TUNING_TEXT_BASE;
+   relocate_code (addr_sp, 0, addr);
+  }
+ #endif
+#endif
+
+     return 0;
+}
+
+
+/*
+ * Breath some life into the board...
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	init_func_ram,
+	checkboard,
+	NULL,
+};
+
+
+void board_init_f(ulong bootflag)
+{
+	gd_t gd_data, *id;
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	ulong addr, addr_sp, len = (ulong)&uboot_end - CONFIG_BOOTSTRAP_TEXT_BASE;
+	ulong *s;
+
+	/* Pointer is writable since we allocated a register for it.
+	 */
+	gd = &gd_data;
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset ((void *)gd, 0, sizeof (gd_t));
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang();
+		}
+	}
+
+	/*
+	 * Now that we have DRAM mapped and working, we can
+	 * relocate the code and continue running from DRAM.
+	 */
+	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
+
+	/* We can reserve some RAM "on top" here.
+	 */
+
+	/* round down to next 4 kB limit.
+	 */
+	addr &= ~(4096 - 1);
+	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
+
+	/* Reserve memory for U-Boot code, data & bss
+	 * round down to next 64 kB limit
+	 */
+	addr -= len;
+	addr &= ~(64 * 1024 - 1);
+    
+	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+
+	 /* Reserve memory for malloc() arena.
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+	debug ("Reserving %dk for malloc() at: %08lx\n",
+			TOTAL_MALLOC_LEN >> 10, addr_sp);
+
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof(bd_t);
+	bd = (bd_t *)addr_sp;
+	gd->bd = bd;
+	debug ("Reserving %zu Bytes for Board Info at: %08lx\n",
+			sizeof(bd_t), addr_sp);
+
+	addr_sp -= sizeof(gd_t);
+	id = (gd_t *)addr_sp;
+	debug ("Reserving %zu Bytes for Global Data at: %08lx\n",
+			sizeof (gd_t), addr_sp);
+
+	/* Reserve memory for boot params.
+	 */
+	addr_sp -= CONFIG_SYS_BOOTPARAMS_LEN;
+	bd->bi_boot_params = addr_sp;
+	debug ("Reserving %dk for boot params() at: %08lx\n",
+			CONFIG_SYS_BOOTPARAMS_LEN >> 10, addr_sp);
+
+	/*
+	 * Finally, we set up a new (bigger) stack.
+	 *
+	 * Leave some safety gap for SP, force alignment on 16 byte boundary
+	 * Clear initial stack frame
+	 */
+	addr_sp -= 16;
+	addr_sp &= ~0xF;
+	s = (ulong *)addr_sp;
+	*s-- = 0;
+	*s-- = 0;
+	addr_sp = (ulong)s;
+	debug ("Stack Pointer at: %08lx\n", addr_sp);
+
+	/*
+	 * Save local variables to board info struct
+	 */
+	bd->bi_memstart	= CONFIG_SYS_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize	= gd->ram_size;		/* size  of  DRAM memory in bytes */
+	bd->bi_baudrate	= gd->baudrate;		/* Console Baudrate */
+
+	memcpy (id, (void *)gd, sizeof (gd_t));
+
+	relocate_code (addr_sp, id, addr);
+
+	/* NOTREACHED - relocate_code() does not return */
+}
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void board_init_r (gd_t *id, ulong dest_addr)
+{
+	 ulong   addr;
+   ulong   data, len, checksum;
+   ulong  *len_ptr;
+   unsigned int destLen;
+   image_header_t header;
+   image_header_t *hdr = &header;
+   int (*fn)();
+	 
+	 mem_malloc_init(dest_addr-TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);
+	 addr = (char *)(CONFIG_BOOTSTRAP_TEXT_BASE + ((ulong)&uboot_end_data - dest_addr));
+   memmove (&header, (char *)addr, sizeof(image_header_t));
+   
+	 if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+        return;
+    }
+
+   data = (ulong)&header;
+   len  = sizeof(image_header_t);
+
+   checksum = ntohl(hdr->ih_hcrc);
+   hdr->ih_hcrc = 0;
+   asm("sync");
+   if (crc32 (0, (char *)data, len) != checksum) {
+        return;
+    }
+
+   asm("sync");
+
+   data = addr + sizeof(image_header_t);
+
+   asm("sync");
+
+   len  = ntohl(hdr->ih_size);
+   asm("sync");
+
+   len_ptr = (ulong *)data;
+   asm("sync");
+
+   destLen = 0x0; 
+   
+/*    
+   int ret = lzmaBuffToBuffDecompress(
+                    (char*)ntohl(hdr->ih_load),
+                    &destLen, (char *)data, len);
+*/
+   lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+									
+   fn = ntohl(hdr->ih_load);
+
+   (*fn)();
+
+    hang ();
+	
+						   
+}
+
+
+void hang(void)
+{
+	
+	 for(;;);
+}
--- /dev/null
+++ b/lib_bootstrap/nand_spl_board.c
@@ -0,0 +1,143 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <environment.h>
+
+
+#define	TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+void mem_malloc_init(ulong start, ulong size)
+{
+	 mem_malloc_end = start + size;
+   mem_malloc_start = start;
+   mem_malloc_brk = start;
+
+   memset ((void *) mem_malloc_start,
+        0,
+       mem_malloc_end - mem_malloc_start);
+	  
+}
+
+void *malloc(unsigned int size)
+{
+    if(size < (mem_malloc_end - mem_malloc_start))
+    {
+        mem_malloc_start += size;
+        return (void *)(mem_malloc_start - size);
+    }
+    return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+    return NULL;
+}
+
+void free(void *src)
+{
+    return;
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+    ulong old = mem_malloc_brk;
+    ulong new = old + increment;
+
+    if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+        return (NULL);
+    }
+    mem_malloc_brk = new;
+    return ((void *) old);
+}
+
+
+
+void uncompress(void)
+{
+	 ulong   addr;
+   ulong   data, len, checksum;
+   ulong  *len_ptr;
+   unsigned int destLen;
+   image_header_t header;
+   image_header_t *hdr = &header;
+   int (*fn)();
+	 
+	 mem_malloc_init(0x82000000-TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);
+	 addr = (char *)(CONFIG_BOOTSTRAP_TEXT_BASE+10240); /*10k bytes for lzma uncompression code*/
+   memmove (&header, (char *)addr, sizeof(image_header_t));
+   
+	 if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+        return;
+    }
+
+   data = (ulong)&header;
+   len  = sizeof(image_header_t);
+
+   checksum = ntohl(hdr->ih_hcrc);
+   hdr->ih_hcrc = 0;
+   asm("sync");
+   if (crc32 (0, (char *)data, len) != checksum) {
+        return;
+    }
+
+   asm("sync");
+
+   data = addr + sizeof(image_header_t);
+
+   asm("sync");
+
+   len  = ntohl(hdr->ih_size);
+   asm("sync");
+
+   len_ptr = (ulong *)data;
+   asm("sync");
+
+   destLen = 0x0; 
+   
+
+   lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+									
+   fn = ntohl(hdr->ih_load);
+
+   (*fn)();
+
+    hang ();   
+	
+	 return;
+}
+
+
+void hang(void)
+{
+	
+	 for(;;);
+}
\ No newline at end of file
--- /dev/null
+++ b/lib_bootstrap/tune_ddr.c
@@ -0,0 +1,1158 @@
+/*****************************************************************************
+ * CPE Chip Rev1 DDR TUNING
+ * Support : Danube, ARX & VRX Platform
+ *
+ * IFAP DC COM SD
+ *****************************************************************************/
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+
+#ifdef CONFIG_LANTIQ_UBOOT_ar9
+#define ARX_CHIP
+#include <asm/ar9.h>
+#elif defined(CONFIG_LANTIQ_UBOOT_danube)
+#define DANUBE_CHIP
+#elif defined(CONFIG_LANTIQ_UBOOT_vr9)
+#define VRX_CHIP
+#elif defined(CONFIG_LANTIQ_UBOOT_ar10)
+#define VRX_CHIP
+#endif
+
+#define asc_puts serial_puts
+#define asc_putc serial_putc
+
+u8 mode;
+u8 cur_state=0;
+u32 ddrsize,chipid;
+
+/* Bootstrap modules */
+//#include "ssc.h"
+//#include "sflash.h"
+//#include "nand.h"
+//#include "test.h"
+//#include "eeprom.h"
+//#include "iccp.h"
+
+//;boot_data bootrom;
+#define DEBUGMODE 0         // debug mode will display more info of auto-tuning result
+
+#ifdef ARX_CHIP // ARX CHIP
+#define READMIN 0
+#define READMAX 0x3f
+#define READMIN_Q 0x1
+#define READMAX_Q 0x20
+#define DQSOUTSHIFT 0x68
+#define WRITEDQS_Q 0x3e
+#define WRITEMIN 0x27
+#define WRITEMAX 0x67
+#define MC_START 0xbf801030
+#define REG01   0xBE1A7F10
+#define REG02   0xBE1A7F14
+#define REG03   0xBE1A7F18
+#define REG04   0xBE1A7F1C
+#define STATUS  0xBE1A7F20
+#endif
+
+#ifdef DANUBE_CHIP // DANUBE CHIP
+#define READMIN 0
+#define READMAX 0x3f
+#define READMIN_Q 0x1
+#define READMAX_Q 0x20
+#define DQSOUTSHIFT 0x64
+#define WRITEDQS_Q 0x3e
+#define WRITEMIN 0x24
+#define WRITEMAX 0x64
+#define MC_START 0xbf801030
+#define REG01   0xBE1A5F10
+#define REG02   0xBE1A5F14
+#define REG03   0xBE1A5F18
+#define REG04   0xBE1A5F1C
+#define STATUS  0xBE1A5F20
+#endif
+
+
+#ifdef VRX_CHIP // VRX CHIP
+#define READMIN 0
+#define READMAX 0x3f
+#define READMIN_Q 0x15
+#define READMAX_Q 0x2b
+#define WRITEDQS_Q 0x55
+#define WRITEMIN 0x40
+#define WRITEMAX 0x7f
+#define MC_START     0xbf401070
+#define REG01   0xBE22FF10
+#define REG02   0xBE22FF14
+#define REG03   0xBE22FF18
+#define REG04   0xBE22FF1C
+#define STATUS  0xBE22FF20
+#endif
+
+//#define REG32(addr) (*(volatile u32*)(addr))
+//#define REG16(addr) (*(volatile u16*)(addr))
+//#define REG8(addr) (*(volatile u8*)(addr))
+
+/* VRX Memory controller register for data-eye tuning */
+#define MC_RD_SLICE0    0xBF401270
+#define MC_RD_SLICE1    0xBF401280
+#define MC_WR_SLICE0    0xBF4012B0
+#define MC_WR_SLICE1    0xBF4012C0
+#define MC_DLL_SLICE0   0xBF4012F0
+#define MC_DLL_SLICE1   0xBF401300
+#define MC_INT_STAT     0xBF401160
+
+/* ARX & Danube Memory controller register for data-eye tuning */
+#define MC_STAT  0xBF800070     // DLL lock status
+#define MC_DC15	 0xBF8010F0     // WRITE DQS
+#define MC_DC21	 0xBF801150     // Data Slice 0
+#define MC_DC22	 0xBF801160     // Data Slice 1
+#define MC_DC24	 0xBF801180     // DQS Out Shift
+
+// Declare a reference to the global pointer
+extern unsigned int _gp;
+
+//extern void cache_enable();
+//extern u32 dma_memcopy_test();
+
+#ifdef ARX_CHIP
+/******************************************************************************
+ * Local routines
+ ******************************************************************************/
+
+#define DFE_BASE_ADDR         0xBE116000
+#define mei_dbg_deco_c        (DFE_BASE_ADDR + 0x00000030)
+#define mei_fr_arcint_c       (DFE_BASE_ADDR + 0x0000001C)
+#define mei_dbg_master_c      (DFE_BASE_ADDR + 0x0000003C)
+#define mei_dbg_waddr_c       (DFE_BASE_ADDR + 0x00000024)
+#define mei_dbg_raddr_c       (DFE_BASE_ADDR + 0x00000028)
+#define mei_dbg_data_c        (DFE_BASE_ADDR + 0x0000002C)
+
+#define ADSL_BASE 0x20000
+#define CRI_BASE          ADSL_BASE + 0x11F00
+#define CRI_CCR0          CRI_BASE + 0x00
+#define CRI_CCR1          CRI_BASE + 0x01*4
+#define CRI_UPDCTL        CRI_BASE + 0x0D*4
+#define CRI_EVENT0        CRI_BASE + 0x10*4
+#define CRI_EVENT1        CRI_BASE + 0x11*4
+#define CRI_EVENT2        CRI_BASE + 0x12*4
+//#define REG32(addr)		   *((volatile u32 *)(addr))
+// Register Definitions
+#define aux_access 0x0
+#define dmp_access 0x1 // or 0x2
+#define core_access 0x3
+
+#define iri_i_enable	0x32000
+#define sty_smode	0x3c004
+
+#define afe_tcr_0	0x3c0dc
+#define afe_addr_addr	0x3c0e8
+#define afe_rdata_addr	0x3c0ec
+#define afe_wdata_addr	0x3c0f0
+#define afe_config	0x3c0f4
+#define afe_serial_cfg	0x3c0fc
+
+
+u32 mei = 0x1;
+u32 jtag = 0x0;
+u32 dmp_core_access = 0x2;
+
+void mei_master(u32 mode){
+  REG32(mei_dbg_master_c) = mode; // MEI as the master
+};
+
+void poll_status(void){
+  while( (REG32(mei_fr_arcint_c) & 0x20) != 0x20 ){};
+};
+
+void mei_dmp_acc(void){
+  REG32(mei_dbg_deco_c) = dmp_access;
+};
+
+u32 ReadARCmem(u32 addr){
+  u32 data;
+  mei_master(mei);
+  mei_dmp_acc();
+  REG32(mei_dbg_raddr_c) = addr;
+  poll_status();
+  data = REG32(mei_dbg_data_c);
+  mei_master(jtag);
+  return data;
+};
+
+void WriteARCmem(u32 addr, u32 data){
+  mei_master(mei);
+  mei_dmp_acc();
+  REG32(mei_dbg_waddr_c) = addr;
+  REG32(mei_dbg_data_c) = data;
+  poll_status();
+  mei_master(jtag);
+};
+
+u32 afe_reg_read(u32 addr)
+{
+	WriteARCmem(CRI_EVENT2,0x20);
+	WriteARCmem(afe_addr_addr,addr);
+	WriteARCmem(afe_rdata_addr,0x0);
+	while((ReadARCmem(CRI_EVENT2)&0x20)!=0x20);
+	return(ReadARCmem(afe_rdata_addr));
+}
+
+u16 afe_reg_write(u32 addr,u32 data)
+{
+	WriteARCmem(afe_addr_addr,addr);
+	WriteARCmem(afe_wdata_addr,data);
+	while((ReadARCmem(CRI_EVENT2)&0x20)!=0x20);
+	return 0;
+}
+
+u16 enable_afe()
+{	
+	u32	read_data,i;
+
+	read_data = REG32(0xbf10201c);
+	REG32(0xbf10201c) = read_data & 0xffff7dbe;
+	//asc_puts("Enabling AFE....\n");
+	/* Start the clock */
+	WriteARCmem(CRI_UPDCTL, 0x08);
+	WriteARCmem(CRI_CCR0, 0x14);
+	WriteARCmem(CRI_CCR1, 0x500); 
+	WriteARCmem(afe_config,0x01c8); 
+	WriteARCmem(afe_serial_cfg,0x16); // (DANUBE_PCI_CFG_BASE+(1<<addrline))AFE serial interface clock & data latch edge
+	WriteARCmem(afe_tcr_0,0x2);
+	//Take afe out of reset
+	WriteARCmem(afe_config,0x0c0); 
+	WriteARCmem(iri_i_enable,0x0101); 
+	WriteARCmem(sty_smode,0x01980); 
+	for(i=0;i<0x100;i++);
+	afe_reg_write(0x4c,0x3);
+	
+	return(0);
+
+}
+#endif
+
+void print_u8(u8 data)
+{
+   char string[3]={0,0,0};
+   char ascii[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+   string[0]=ascii[(data&0xf0)>>4];
+   string[1]=ascii[data&0xf];
+
+   asc_puts(string);
+}
+
+void print_u32(u32 data)
+{
+   print_u8( (u8) (data>>24)&0xff);
+   print_u8( (u8) (data>>16)&0xff);
+   print_u8( (u8) (data>>8)&0xff);
+   print_u8( (u8) (data>>0)&0xff);
+}
+
+#if 1
+void print_state()
+{
+	switch(cur_state)
+	{
+		case 0:  asc_puts("\b\b\b[-]");
+				 cur_state=1;
+				 break;
+		case 1:  asc_puts("\b\b\b[\\]");
+				 cur_state=2;
+				 break;
+		case 2:  asc_puts("\b\b\b[|]");
+				 cur_state=3;
+				 break;
+		case 3:  asc_puts("\b\b\b[/]");
+				 cur_state=0;
+				 break;
+	    default: cur_state=0;
+	    		 break;
+	}
+}
+#else
+
+void print_state(char c)
+{
+	asc_puts("\b\b\b["); asc_putc(c);asc_puts("]");
+}
+
+#endif
+
+void debug_print(char* s)
+{
+#if DEBUG
+	asc_puts(s);
+#else
+	 //u32 i;
+	 //for(i=0;i<0xff;i++);
+#endif
+}
+
+#define TESTADDR    0x80100000
+#define TESTADDR_UC 0xA0000000
+#define CHECK_DQ_LINE_FAIL 0
+
+#if CHECK_DQ_LINE_FAIL
+
+void clear_error(u8* data)
+{
+    u8 i;
+
+    for(i=0;i<16;i++)
+        data[i] =0;
+}
+
+u16 check_data_bit_fail(u32 d1, u32 d2, u8* bit)
+{
+    u8 i;
+
+    for(i=0;i<16;i++)
+    {
+        if((((u16)d1) & ~(1<<i))!=(((u16)d2) & ~(1<<i)))
+            bit[i]=1;
+        if((((u16)(d1>>16)) & ~(1<<i))!=(((u16)(d2>>16)) & ~(1<<i)))
+            bit[i]=1;
+    }
+    return(0);
+}
+#endif
+
+u32 d_pattern[8];
+u16 w_pattern[4];
+u8  b_pattern[4];
+
+void init_pattern()
+{
+    b_pattern[0]=0x55;
+    b_pattern[1]=0x00;
+    b_pattern[2]=0xFE;
+    b_pattern[3]=0x01;
+
+    w_pattern[0]=0x5555;
+    w_pattern[1]=0xFFFF;
+    w_pattern[2]=0x8000;
+    w_pattern[3]=0x7FFF;
+
+    d_pattern[0]=0x5555aaaa;
+    d_pattern[1]=0xFFFF0000;
+    d_pattern[2]=0x80000001;
+    d_pattern[3]=0x7FFFFFFE;
+    d_pattern[4]=0x12345678;
+    d_pattern[5]=0x9ABCDEF0;
+    d_pattern[6]=0xC3C3C3C3;
+    d_pattern[7]=0xFFFFFFFF;
+}
+
+u32 sdramtest(u8 masktype, u8 mode)
+{
+    u32 j,k,l;
+    u32 x;
+    u32 mask,pattern;
+    u16 wmask;
+    u8 bmask;
+    //u8  dq_error[16];
+    if (masktype == 0) mask =0x00ff00ff;
+    else if(masktype==1) mask = 0xff00ff00;
+    else mask = 0xffffffff;
+
+    wmask =(u16) mask;
+    bmask = (u8) mask;
+
+// Test# 1 32bit short Uncache Access
+    //print_state('a');
+    for(j=0;j<8;j++)
+    {
+        for(k=0;k<0x20;k=k+4)
+        {
+            l=j;
+            REG32(TESTADDR_UC+(j<<16)+k)=d_pattern[l];
+            REG32(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k)=~d_pattern[l];
+        }
+    }
+    //print_state('b');
+    for(j=0;j<8;j++)
+    {
+        for(k=0;k<0x20;k=k+4)
+        {
+            l=j;
+            x = REG32(TESTADDR_UC+(j<<16)+k);
+            if((x&mask)!=(d_pattern[l]&mask))
+                return(1);
+            x = REG32(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k);
+            if((x&mask)!=((~d_pattern[l])&mask))
+                return(1);
+        }
+    }
+
+    if(mode != 1) // Normal mode 1: Quick test
+    {
+    // Test# 2 16bit Uncache Access
+    	//print_state('c');
+        for(j=0;j<4;j++)
+        {
+            for(k=0;k<0x40;k=k+2)
+            {
+                l=j;
+                REG16(TESTADDR_UC+(j<<16)+k)=w_pattern[l];
+                REG16(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k)=~w_pattern[l];
+            }
+        }
+    	//print_state('d');
+        for(j=0;j<4;j++)
+        {
+            for(k=0;k<0x40;k=k+2)
+            {
+                l=j;
+                x = REG16(TESTADDR_UC+(j<<16)+k);
+                if((x&wmask)!=(w_pattern[l]&wmask))
+                    return(1);
+                x = REG16(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k);
+                if((x&wmask)!=((~w_pattern[l])&wmask))
+                    return(1);
+            }
+        }
+
+    // Test# 3 8bit Uncache Access
+    	//print_state('e');
+        for(j=0;j<4;j++)
+        {
+            for(k=0;k<0x80;k=k+1)
+            {
+                l=j;
+                REG8(TESTADDR_UC+(j<<16)+k)=b_pattern[l];
+                REG8(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k)=~b_pattern[l];
+            }
+        }
+    	//print_state('f');
+        for(j=0;j<4;j++)
+        {
+            for(k=0;k<0x80;k=k+1)
+            {
+                l=j;
+                x = REG8(TESTADDR_UC+(j<<16)+k);
+                if((x&bmask)!=(b_pattern[l]&bmask))
+                    return(1);
+                x = REG8(TESTADDR_UC+(ddrsize>>1)+(j<<16)+k);
+                if((x&bmask)!=((~b_pattern[l])&bmask))
+                    return(1);
+            }
+        }
+
+    // Test# 4 32bit Cache Access Random Pattern (short)
+    	//print_state('g');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x100;k=k+4)
+            {
+                l=(j+(k>>2))%8;
+                REG32(TESTADDR+(j<<16)+k)=d_pattern[l];
+                REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k)=~d_pattern[l];
+            }
+        }
+    	//print_state('h');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x100;k=k+4)
+            {
+                l=(j+(k>>2))%8;
+                x = REG32(TESTADDR+(j<<16)+k);
+                if((x&mask)!=(d_pattern[l]&mask))
+                    return(1);
+                x = REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k);
+                if((x&mask)!=((~d_pattern[l])&mask))
+                    return(1);
+            }
+        }
+
+    // Test# 5 32bit Cache Access Checker Pattern (short)
+        pattern=0x55555555;
+    	//print_state('i');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x400;k=k+4)
+            {
+                REG32(TESTADDR+(j<<16)+k)=pattern;
+                REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k)=~pattern;
+            }
+        }
+    	//print_state('j');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x400;k=k+4)
+            {
+                x = REG32(TESTADDR+(j<<16)+k);
+                if((x&mask)!=(pattern&mask))
+                    return(1);
+                x = REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k);
+                if((x&mask)!=((~pattern)&mask))
+                    return(1);
+            }
+        }
+
+    // Test# 6 32bit Cache Access Moving 0 & 1 Pattern
+    	//print_state('k');
+        for(j=0;j<8;j++)
+        {
+            pattern=0x10001;
+            for(k=0;k<0x400;k=k+4)
+            {
+                REG32(TESTADDR+(j<<16)+k)=pattern;
+                REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k)=~pattern;
+                pattern=pattern<<1;
+                if(pattern==0) pattern=0x10001;
+            }
+        }
+    	//print_state('l');
+        for(j=0;j<8;j++)
+        {
+            pattern=0x10001;
+            for(k=0;k<0x400;k=k+4)
+            {
+                x = REG32(TESTADDR+(j<<16)+k);
+                if((x&mask)!=(pattern&mask))
+                    return(1);
+                x = REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k);
+                if((x&mask)!=((~pattern)&mask))
+                    return(1);
+                pattern=pattern<<1;
+                if(pattern==0) pattern=0x10001;
+            }
+        }
+
+    // Test# 7 32bit Cache Access Random Pattern (long)
+    	//print_state('m');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x4000;k=k+4)
+            {
+                l=(j+(k>>2)+2)%8;
+                REG32(TESTADDR+(j<<16)+k)=d_pattern[l];
+                REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k)=~d_pattern[l];
+            }
+        }
+    	//print_state('n');
+        for(j=0;j<8;j++)
+        {
+            for(k=0;k<0x4000;k=k+4)
+            {
+                l=(j+(k>>2)+2)%8;
+                x = REG32(TESTADDR+(j<<16)+k);
+                if((x&mask)!=(d_pattern[l]&mask))
+                    return(1);
+                x = REG32(TESTADDR+(ddrsize>>1)+(j<<16)+k);
+                if((x&mask)!=((~d_pattern[l])&mask))
+                    return(1);
+            }
+        }
+    }
+
+    return(0);
+}
+
+/******************************************************************************
+ * Global routines
+ ******************************************************************************/
+
+void tune_ddr(void)
+{
+	u32 min_l, max_l, max_u, min_u;
+	u32 write_l, read_l, read_u;
+    u32 readq_l, readq_u;
+	u32 l,u,k,i,j;
+	u16 pass=0;
+	u8 test_l[128], test_u[128];
+#ifdef VRX_CHIP
+    u32 write_u;
+#endif
+
+	ddrsize=0x20000000;
+	for(k=0;k<128;k++)
+    {
+        test_l[k]=0;
+        test_u[k]=0;
+    }
+	//cache_enable();
+	for(k=0;k<0xffff;k++);
+
+	chipid = REG32(0xbf107344);
+
+    REG32(0xbe100b1c) &= ~(1<<3);
+    REG32(0xbe100b20) &= ~(1<<3);
+#ifdef	ARX_CHIP
+	enable_afe();
+#endif
+
+#if 0 // asc_init not needed to be done by u-boot
+	asc_init();
+#endif
+	asc_puts("DDR autotuning Rev 0.3c\n");
+#if 0 // Chip ID detection not required
+	//print_state('0');
+    switch(chipid & 0x0fffffff)
+    {
+		case 0x0016d083 :
+			 asc_puts("ARX 168 chip found\n");
+			 if((fpiclock & 0x18) != 0 )
+			 {
+			 	  asc_puts("CGU_SYS setting not supported by ARX188, Exit!!!\n");
+			 	  goto end;
+			 }
+			 break;
+		case 0x0016c083 :
+			 asc_puts("ARX188 found\n");
+			 break;
+		case 0x00171083 :
+			 asc_puts("GRX168 found\n");
+			 break;
+		case 0x00170083 :
+			 asc_puts("GRX188 found\n");
+			 break;
+	    default:
+			 asc_puts("XRX1xx found\n");
+			 break;
+	}
+#endif
+#ifdef VRX_CHIP
+    ddrsize = ddrsize << 1;
+	ddrsize = ddrsize >> ((REG32(0xBF4010B0)&0x7)) ;
+    //Row Address; 0=14, 1=13, 2=12, 3=11, 4=10
+	ddrsize = ddrsize >> ((REG32(0xBF4010B0)>>24)&0x7) ;
+    //Col Address; 0=12, 1=11, 2=10, 3=9, 4=8;
+	ddrsize = ddrsize >> ((~(REG32(0xBF401030)))&0x1) ;
+    //Bank Address;
+	switch ((REG32(0xBF401080)>>24)&0x3)
+	{
+		   case 1:
+		   		k=0;
+		   		break;
+   		   case 3:
+   		   		k=1;
+   		   		break;
+   		   default:
+   		        asc_puts("Wrong Chip select, EXIT\n");
+   		        goto end;
+   		        break;
+	}
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+	ddrsize = ddrsize >> (((REG32(0xBF801130)>>8)&0x7)-2) ;
+	ddrsize = ddrsize >> ((REG32(0xBF801140))&0x7) ;
+	switch ((REG32(0xBF8010F0)>>8)&0xf)
+	{
+		   case 1:
+		   		k=0;
+		   		break;
+   		   case 3:
+   		   		k=1;
+   		   		break;
+           case 0xf:
+           		k=2;
+           		break;
+   		   default:
+   		        asc_puts("Wrong Chip select, EXIT\n");
+   		        goto end;
+   		        break;
+	}
+#endif
+	ddrsize = ddrsize << k;
+	//print_u32(ddrsize); asc_putc('\n');
+#if 0
+	testch=asc_getc();
+	if(testch=='~') mode =2;
+	else if (testch=='*') {mode =1; asc_puts("Debug mode tunning started\n");}
+	else if (testch=='&') {mode =1;
+		 	asc_puts("Debug mode tunning started with Class II\n");
+			REG32(0xBF103020) |= (1<<21);
+			REG32(0xBF103014) = 1;
+		 }
+	else mode =0;
+#else
+	 mode =0;
+#endif
+
+#if 0 // no need to determine clock speed.
+    switch(fpiclock &0x19)
+    {
+            case 0x1 :
+	            asc_puts("DDR set @ 111.1MHz\n");
+                break;
+            case 0x10:
+	    		if(REG32(0xbf103008)==0x9800f25f)
+				    asc_puts("DDR set @ 166.6MHz\n");
+				else if(REG32(0xbf103008)==0x9d26f017)
+				    asc_puts("DDR set @ 196.6Mhz\n");
+				else
+				{
+					asc_puts("DDR set @ 221.2Mhz\n");
+					REG32(0xBF103020) |= (1<<21);
+					REG32(0xBF103014) = 1;
+				}
+				break;
+	    	case 0x9:
+	    	case 0x0:
+        	/*115200 @83.3M, delta 0.000231*/
+	            asc_puts("DDR set @ 166.6MHz\n");
+                break;
+	    	case 0x8:
+        	/*115200 @83.3M, delta 0.000231*/
+            	asc_puts("DDR set @ 250MHz\n");
+				REG32(0xBF103020) |= (1<<21);
+				REG32(0xBF103014) = 1;
+                break;
+    }
+#endif
+	asc_puts("DDR size from 0xa0000000 - 0x"); print_u32(0xa0000000+(ddrsize-1));asc_putc('\n');
+	//asc_puts("DDR DLL lock element = "); print_u32((REG32(0xbf801150)&0x7f));asc_putc('\n');
+  init_pattern();
+  if(REG32(STATUS)==0x0)
+  {
+	   if(sdramtest(2,0)==0) pass=1; //asc_puts("Initial DDR setting for SDRAM test pass\n");
+  }
+
+	if(pass)
+	{
+		asc_puts("DDR check ok... start booting...\n\n");
+		REG32(STATUS)=0x1;
+		goto start_uboot;
+	}
+	/*
+	else
+	{
+		if(REG32(STATUS)!=0xff)
+  		    asc_puts("Unknown command from u-boot\n");
+		pass=0;
+		asc_puts("Start DDR tuning ");
+	}
+	*/
+	REG32(STATUS)=0x10;
+
+    cur_state=1;
+    asc_puts("[-]");
+
+/* -------------------------------------------------------------------- */
+/* Perform quick test to determine the inital readdqs for write tunning */
+#if DEBUGMODE
+	for(k=0;k<128;k++)
+    {
+        test_l[k]=0;
+        test_u[k]=0;
+    }
+#endif
+
+	min_l = READMAX_Q;
+	max_l = READMIN_Q;
+	min_u = READMAX_Q;
+	max_u = READMIN_Q;
+
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+    REG32(MC_DC24) = (REG32(MC_DC24) & (~((u32)0xff))) | DQSOUTSHIFT;        // Program for the fix DQS out shift
+#endif
+    for(j=0;j<15;j++)
+    {
+    	//print_state('1');
+    	asm("sync");
+        REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+        REG32(MC_WR_SLICE0) = (REG32(MC_WR_SLICE0)&0xff00ff)| ((WRITEDQS_Q+j)<<8);
+        REG32(MC_WR_SLICE1) = (REG32(MC_WR_SLICE1)&0xff00ff)| ((WRITEDQS_Q+j)<<8);
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+        REG32(MC_DC15) = (REG32(MC_DC15) & ~0xff) | (WRITEDQS_Q+j);
+#endif
+        for(k=READMIN_Q;k<READMAX_Q;k++)
+        {
+    	    //print_state('2');
+    	    asm("sync");
+            REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+            REG32(MC_RD_SLICE0) = (REG32(MC_RD_SLICE0)&0xff00ff)| k<<8;
+            REG32(MC_RD_SLICE1) = (REG32(MC_RD_SLICE1)&0xff00ff)| k<<8;
+            REG32(MC_START) = 0x1010100;
+            while(((REG32(MC_INT_STAT)&0x4000000)!=0x4000000) || (((REG32(MC_DLL_SLICE0)&0x1)&(REG32(MC_DLL_SLICE1)&0x1))==0));
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+            REG32(MC_DC22) = (REG32(MC_DC22) & (~((u32)0xffff))) | k | k<<0x8;
+            REG32(MC_DC21) = (REG32(MC_DC21) & (~((u32)0xff00))) | k<<0x8;
+	        REG32(MC_START) = 0x00000100;
+	        {
+	        	int timeout_cnt=0;
+	          while( (REG32(MC_STAT)&0x4)!=0x4 || (REG32(MC_STAT)&0x8)!=0x8 ){
+	          	 timeout_cnt++;
+	          	 __udelay(1);
+	          	 if(timeout_cnt>100){asc_puts("status timeout\n"); break;}
+	          };
+	        }
+#endif
+    	    asm("sync");
+            __udelay(5);
+            l=0; u=0;
+            if(sdramtest(0,1)==0)
+            {
+                l=1;
+                if(min_l > k) min_l = k;
+                if(max_l < k) max_l = k;
+            }
+            print_state();
+            if(sdramtest(1,1)==0)
+            {
+                u=1;
+                if(min_u > k) min_u = k;
+                if(max_u < k) max_u = k;
+            }
+            test_l[k]=l;
+            test_u[k]=u;
+        }
+    }
+    if( max_l > min_l)
+        readq_l = (min_l+max_l)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable read DQS delay for slice 0!\n");
+        goto end;
+    }
+    if( max_u > min_u)
+        readq_u = (min_u+max_u)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable read DQS delay for slice 1!\n");
+        goto end;
+    }
+
+
+/*-----------------End of Quick Test to determine Read DQS-------------------------------*/
+/*---------------------------------------------------------------------------------------*/
+
+   //__udelay(50);
+
+/*---------------------------------------------------------------------------------------*/
+/*------------------------ Start of Write Data Eye Tuning -------------------------------*/
+
+#if DEBUGMODE
+	for(k=0;k<128;k++)
+    {
+        test_l[k]=0;
+        test_u[k]=0;
+    }
+#endif
+
+    min_l = WRITEMAX;
+    max_l = WRITEMIN;
+    min_u = WRITEMAX;
+    max_u = WRITEMIN;
+
+	for(k=0;k<0x1fff;k++);
+ 	print_state();
+    asm("sync");
+
+    REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+    REG32(MC_RD_SLICE0) = (REG32(MC_RD_SLICE0)&0xff00ff)| readq_l<<8;
+    REG32(MC_RD_SLICE1) = (REG32(MC_RD_SLICE1)&0xff00ff)| readq_u<<8;
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+    REG32(MC_DC22) = (REG32(MC_DC22) & (~((u32)0xffff))) | readq_u | readq_u <<0x8;
+    REG32(MC_DC21) = (REG32(MC_DC21) & (~((u32)0xff00))) | readq_l<<0x8;
+#endif
+    for(k=WRITEMIN;k<WRITEMAX;k++)
+    {
+        asm("sync");
+        REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+        REG32(MC_WR_SLICE0) = (REG32(MC_WR_SLICE0)&0xff00ff)| k<<8;
+        REG32(MC_WR_SLICE1) = (REG32(MC_WR_SLICE1)&0xff00ff)| k<<8;
+
+        REG32(MC_START) = 0x1010100;
+        while(((REG32(MC_INT_STAT)&0x4000000)!=0x4000000) || (((REG32(MC_DLL_SLICE0)&0x1)&(REG32(MC_DLL_SLICE1)&0x1))==0));
+        asm("sync");
+
+        l=0; u=0;
+        if(sdramtest(0,0)==0)
+        {
+            l=1;
+            if(min_l > k) min_l = k;
+            if(max_l < k) max_l = k;
+        }
+
+        if(sdramtest(1,0)==0)
+        {
+            u=1;
+            if(min_u > k) min_u = k;
+            if(max_u < k) max_u = k;
+        }
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+        REG32(MC_DC15) = (REG32(MC_DC15) & ~0xff) | (k);
+
+        REG32(MC_START) = 0x00000100;
+         {
+	        	int timeout_cnt=0;
+	          while( (REG32(MC_STAT)&0x4)!=0x4 || (REG32(MC_STAT)&0x8)!=0x8 ){
+	          	 timeout_cnt++;
+	          	 __udelay(1);
+	          	 if(timeout_cnt>100){asc_puts("status timeout\n"); break;}
+	          };
+	        }
+
+
+        asm("sync");
+        __udelay(5);
+        l=0;
+        if(sdramtest(2,0)==0)
+        {
+            l=1;
+            if(min_l > k) min_l = k;
+            if(max_l < k) max_l = k;
+        }
+#endif
+	print_state();
+
+#if DEBUGMODE
+        test_l[k]=l;
+        test_u[k]=u;
+#endif
+    }
+#if DEBUGMODE
+#ifdef VRX_CHIP
+    asc_puts("\n Show slice 0 write setting\n");
+    for(k=WRITEMIN; k< WRITEMAX+1; k++)
+    {
+        if(test_l[k]==0)
+              asc_putc('0');
+        else asc_putc('1');
+        if(k%16 == 15) asc_putc('\n');
+        else asc_putc(' ');
+    }
+
+    asc_puts("\n Show slice 1 write setting\n");
+    for(k=WRITEMIN; k< WRITEMAX+1; k++)
+    {
+        if(test_u[k]==0)
+              asc_putc('0');
+        else asc_putc('1');
+        if(k%16 == 15) asc_putc('\n');
+        else asc_putc(' ');
+    }
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+    asc_puts("\n Show Write DQS setting\n");
+    for(k=WRITEMIN; k< WRITEMAX+1; k++)
+    {
+        if(test_l[k]==0)
+              asc_putc('0');
+        else asc_putc('1');
+        if(k%16 == 15) asc_putc('\n');
+        else asc_putc(' ');
+    }
+#endif
+#endif
+    //print_state('9');
+    if( max_l > min_l)
+        write_l = (min_l+max_l)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable write DQS delay for slice 0!\n");
+        goto end;
+    }
+#ifdef VRX_CHIP
+    if( max_u > min_u)
+        write_u = (min_u+max_u)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable write DQS delay for slice 1!\n");
+        goto end;
+    }
+#endif
+
+	REG32(STATUS)=0x11;
+/*------------------------ End of Write Data Eye Tuning ---------------------------------*/
+/*---------------------------------------------------------------------------------------*/
+   //__udelay(50);
+
+/*---------------------------------------------------------------------------------------*/
+/*------------------------ Start of Read Data Eye Tuning --------------------------------*/
+
+#if DEBUGMODE
+	for(k=0;k<128;k++)
+    {
+        test_l[k]=0;
+        test_u[k]=0;
+    }
+#endif
+	min_l = READMAX;
+	max_l = READMIN;
+	min_u = READMAX;
+	max_u = READMIN;
+
+    asm("sync");
+
+    REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+    REG32(MC_WR_SLICE0) = (REG32(MC_WR_SLICE0)&0xff00ff)| write_l<<8;
+    REG32(MC_WR_SLICE1) = (REG32(MC_WR_SLICE1)&0xff00ff)| write_u<<8;
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+    REG32(MC_DC15) = (REG32(MC_DC15) & ~0xff) | (write_l);
+#endif
+    for(k=READMIN;k<READMAX;k++)
+    {
+        //print_state('B');
+        REG32(MC_START) = 0;
+#ifdef  VRX_CHIP
+        REG32(MC_RD_SLICE0) = (REG32(MC_RD_SLICE0)&0xff00ff)| k<<8;
+        REG32(MC_RD_SLICE1) = (REG32(MC_RD_SLICE1)&0xff00ff)| k<<8;
+        REG32(MC_START) = 0x1010100;
+        while(((REG32(MC_INT_STAT)&0x4000000)!=0x4000000) || (((REG32(MC_DLL_SLICE0)&0x1)&(REG32(MC_DLL_SLICE1)&0x1))==0));
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+        REG32(MC_DC22) = (REG32(MC_DC22) & (~((u32)0xffff))) | k | k<<0x8;
+        REG32(MC_DC21) = (REG32(MC_DC21) & (~((u32)0xff00))) | k<<0x8;
+        REG32(MC_START) = 0x00000100;
+   	     {
+	        	int timeout_cnt=0;
+	          while( (REG32(MC_STAT)&0x4)!=0x4 || (REG32(MC_STAT)&0x8)!=0x8 ){
+	          	 timeout_cnt++;
+	          	 __udelay(1);
+	          	 if(timeout_cnt>100){asc_puts("status timeout\n"); break;}
+	          };
+	        }
+
+#endif
+        asm("sync");
+        //print_state('C');
+        __udelay(5);
+        l=0; u=0;
+        if(sdramtest(0,0)==0)
+        {
+            l=1;
+            if(min_l > k) min_l = k;
+            if(max_l < k) max_l = k;
+        }
+        print_state();
+        if(sdramtest(1,0)==0)
+        {
+            u=1;
+            if(min_u > k) min_u = k;
+               if(max_u < k) max_u = k;
+        }
+#if DEBUGMODE
+        test_l[k]=l;
+        test_u[k]=u;
+#endif
+    }
+#if DEBUGMODE
+    asc_puts("\n Show slice 0 read setting\n");
+    for(k=READMIN; k< READMAX+1; k++)
+    {
+        if(test_l[k]==0)
+              asc_putc('0');
+        else asc_putc('1');
+        if(k%16 == 15) asc_putc('\n');
+        else asc_putc(' ');
+    }
+
+    asc_puts("\n Show slice 1 read setting\n");
+    for(k=READMIN; k< READMAX+1; k++)
+    {
+        if(test_u[k]==0)
+              asc_putc('0');
+        else asc_putc('1');
+        if(k%16 == 15) asc_putc('\n');
+        else asc_putc(' ');
+    }
+#endif
+    if( max_l > min_l)
+        read_l = (min_l+max_l)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable read DQS delay for slice 0 !\n");
+        goto end;
+    }
+    if( max_u > min_u)
+        read_u = (min_u+max_u)>>1;
+    else
+    {
+        asc_puts("Can't determine a suitable read DQS delay for slice 1!\n");
+        goto end;
+    }
+	REG32(STATUS)=0x12;
+
+/*------------------------- End of Read Data Eye Tuning ---------------------------------*/
+/*---------------------------------------------------------------------------------------*/
+
+    asm("sync");
+    REG32(MC_START) = 0;
+#ifdef VRX_CHIP
+	asc_puts("\nRead DQS Delay Slice0:"); print_u32(read_l); asc_putc('\n');
+	asc_puts("Read DQS Delay Slice1:"); print_u32(read_u); asc_putc('\n');
+	asc_puts("Write DQS Delay Slice0:"); print_u32(write_l); asc_putc('\n');
+	asc_puts("Write DQS Delay Slice1:"); print_u32(write_u); asc_putc('\n');
+    REG32(MC_RD_SLICE0) = (REG32(MC_RD_SLICE0)&0xff00ff)| read_l<<8;
+    REG32(MC_RD_SLICE1) = (REG32(MC_RD_SLICE1)&0xff00ff)| read_u<<8;
+    REG32(MC_START) = 0x1010100;
+
+            while(((REG32(MC_INT_STAT)&0x4000000)!=0x4000000)|| (((REG32(MC_DLL_SLICE0)&0x1)&(REG32(MC_DLL_SLICE1)&0x1))==0));
+
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+/* TODO print*/
+	asc_puts("\nRead DQS Delay Slice0:"); print_u32(read_l); asc_putc('\n');
+	asc_puts("Read DQS Delay Slice1:"); print_u32(read_u); asc_putc('\n');
+	asc_puts("Write DQS Setting:"); print_u32(write_l); asc_putc('\n');
+	asc_puts("Fix DQS Out Shift:"); print_u32(DQSOUTSHIFT); asc_putc('\n');
+    REG32(MC_DC22) = (REG32(MC_DC22) & (~((u32)0xffff))) | read_u | read_u<<0x8;
+    REG32(MC_DC21) = (REG32(MC_DC21) & (~((u32)0xff00))) | read_l<<0x8;
+    REG32(MC_START) = 0x00000100;
+    	    {
+	        	int timeout_cnt=0;
+	          while( (REG32(MC_STAT)&0x4)!=0x4 || (REG32(MC_STAT)&0x8)!=0x8 ){
+	          	 timeout_cnt++;
+	          	 __udelay(1);
+	          	 if(timeout_cnt>100){asc_puts("status timeout\n"); break;}	          	
+	          };
+	        }  
+
+#endif
+    //for(i=0;i<0x2000;i++);
+    asm("sync");
+    __udelay(5);
+    //print_state();
+	goto store_para;
+end:
+	//TODO: need to decide what happen if tunning fail.....
+	REG32(STATUS) = 0x1f;
+	while(1);
+	//asc_getc();
+store_para:
+#ifdef VRX_CHIP
+	REG32(REG01) = REG32(MC_RD_SLICE0);
+	REG32(REG02) = REG32(MC_RD_SLICE1);
+	REG32(REG03) = REG32(MC_WR_SLICE0);
+	REG32(REG04) = REG32(MC_WR_SLICE1);
+#endif
+#if defined(ARX_CHIP) || defined(DANUBE_CHIP)
+	REG32(REG01) = REG32(MC_DC15);
+	REG32(REG02) = REG32(MC_DC21);
+	REG32(REG03) = REG32(MC_DC22);
+	REG32(REG04) = REG32(MC_DC24);
+#endif
+	REG32(STATUS) = 0x2;
+    asm("sync");
+start_uboot:
+#ifdef CONFIG_BOOT_FROM_NOR	
+	for(k=0;k<0x80;k++); // jump delay
+	void (*jump)(void);
+	jump = (void (*)(void))(0xB0000000);
+	for(k=0;k<0x80;k++); // jump delay
+	(*jump)();
+
+	while(1);
+#endif
+    asm("sync");
+	return;
+	/* TODO: Needs to be updated acc. to final CFG definition! */
+}
+
+
